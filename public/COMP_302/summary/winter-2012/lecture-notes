<head>
    <title>Wikinotes</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.0.0/semantic.min.css" />
    <link rel="stylesheet" href="/static/styles.css" />
    <meta name="viewport" content="width=device-width">
    
<script type="text/javascript"
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    TeX: {
        extensions: ['cancel.js']
    },
    tex2jax: {
        inlineMath: [  ['$', '$'] ],
        processEscapes: true
    }
});
</script>

</head>
<body>
    
    <div id="header" class="ui container">
        <a href="/">
            <img src="/static/img/logo-header.png" class="ui image" />
        </a>
    </div>
    
    <div id="content">
        <div class="ui container">
            
<div class="ui container">
    <div class="ui secondary segment">
        <div class="ui large breadcrumb">
            <a class="section" href="/">Home</a>
            <i class="right chevron icon divider"></i>
            <a class="section" href="/COMP_302/">
                COMP 302
            </a>
            <i class="right chevron icon divider"></i>
            <span class="active section">
                
                Lecture notes
                
            </span>
        </div>
    </div>
    <h1 class="ui header">
        <div class="content">
            
            Lecture notes
            
            <span>
                <a href="http://creativecommons.org/licenses/by-nc/3.0/">
                    <img src="/static/img/cc-by-nc.png" alt="CC-BY-NC"
                         title="Available under a Creative Commons Attribution-NonCommercial 3.0 Unported License" />
                </a>
            </span>
            
        </div>
    </h1>
    <div class="ui icon list">
        <div class="item">
            <i class="user icon"></i>
            <div class="content">
                <strong>Maintainer:</strong> admin
            </div>
        </div>
    </div>
    <div class="ui divider"></div>
    <div id="wiki-content">
	
        <p>These course notes are for COMP 302: Programming Languages and Paradigms, offered at McGill University in the Winter 2012 semester, taught by Professor Brigitte Pientka. These notes are simply an adaptation of what the instructor wrote on the board or mentioned in class, and may contain errors. These notes were originally written in LaTeX by Ryan Ordille (<a href="/users/remo">@remo</a>), and were converted into Markdown and posted on Wikinotes with permission. No copyright infringement is intended.  </p>
<p>These course notes can also be found, in PDF and .tex format, at <a href="https://github.com/ryanordille/c302w12">https://github.com/ryanordille/c302w12</a>.</p>
<div class="toc">
<ul>
<li><a href="#09-january">1 09 January</a><ul>
<li><a href="#introduction-to-functional-programming-in-standard-ml">1.1 Introduction to Functional Programming in Standard ML</a><ul>
<li><a href="#what-are-types">1.1.1 What are types?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#11-january">2 11 January</a><ul>
<li><a href="#bindings-and-scope-of-variables-and-functions">2.1 Bindings and scope of variables and functions</a></li>
<li><a href="#functions">2.2 Functions</a></li>
<li><a href="#recursion-in-sml">2.3 Recursion in SML</a></li>
</ul>
</li>
<li><a href="#13-jan">3 13 Jan</a><ul>
<li><a href="#data-types">3.1 Data types</a><ul>
<li><a href="#lists-in-sml">3.1.1 Lists in SML</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#16-january">4 16 January</a><ul>
<li><a href="#datatypes-continued">4.1 Datatypes continued</a></li>
</ul>
</li>
<li><a href="#18-20-january">5 18 &amp; 20 January</a><ul>
<li><a href="#mathematical-induction">5.1 Mathematical Induction</a></li>
</ul>
</li>
<li><a href="#23-january">6 23 January</a><ul>
<li><a href="#higher-order-functions">6.1 Higher-Order Functions</a></li>
</ul>
</li>
<li><a href="#25-30-january">7 25 &amp; 30 January</a></li>
<li><a href="#03-february">8 03 February</a><ul>
<li><a href="#regular-expression-matching">8.1 Regular Expression Matching</a></li>
</ul>
</li>
<li><a href="#6-february">9 6 February</a><ul>
<li><a href="#exceptions">9.1 Exceptions</a></li>
</ul>
</li>
<li><a href="#8-february">10 8 February</a><ul>
<li><a href="#references-state">10.1 References (State)</a></li>
</ul>
</li>
<li><a href="#10-february">11 10 February</a><ul>
<li><a href="#references-and-the-environment-diagram">11.1 References and the environment diagram</a><ul>
<li><a href="#references-for-modelling-closures-and-objects">11.1.1 References for modelling closures and objects</a></li>
<li><a href="#the-environment-diagram">11.1.2 The Environment Diagram</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#13-february">12 13 February</a><ul>
<li><a href="#lazy-evaluation">12.1 Lazy Evaluation</a></li>
</ul>
</li>
<li><a href="#15-february">13 15 February</a><ul>
<li><a href="#lazy-programming-continued">13.1 Lazy programming continued</a></li>
</ul>
</li>
<li><a href="#27-february">14 27 February</a><ul>
<li><a href="#midterm-review">14.1 Midterm Review</a><ul>
<li><a href="#example-1-proofs">14.1.1 Example 1: Proofs</a></li>
<li><a href="#example-2-rewriting-library-functions">14.1.2 Example 2: Rewriting library functions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#02-march-post-midterm">15 02 March - Post-Midterm</a><ul>
<li><a href="#midterm-review_1">15.1 Midterm review</a><ul>
<li><a href="#question-1">15.1.1 Question 1</a></li>
<li><a href="#question-2">15.1.2 Question 2</a></li>
<li><a href="#question-3">15.1.3 Question 3</a></li>
<li><a href="#question-4">15.1.4 Question 4</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#05-march-post-midterm-material">16 05 March -- Post-Midterm Material</a><ul>
<li><a href="#introduction-to-language-design">16.1 Introduction to Language Design</a></li>
<li><a href="#nano-ml">16.2 Nano ML</a></li>
</ul>
</li>
<li><a href="#07-march">17 07 March</a><ul>
<li><a href="#language-design-and-nano-ml-continued">17.1 Language Design and Nano ML continued</a></li>
<li><a href="#substitution">17.2 Substitution:</a></li>
</ul>
</li>
<li><a href="#09-march">18 09 March</a><ul>
<li><a href="#evaluation">18.1 Evaluation</a></li>
<li><a href="#modules">18.2 Modules</a></li>
</ul>
</li>
<li><a href="#12-march">19 12 March</a><ul>
<li><a href="#types">19.1 Types</a></li>
</ul>
</li>
<li><a href="#14-march">20 14 March</a><ul>
<li><a href="#typing-rules-continued">20.1 Typing rules continued</a></li>
<li><a href="#extensions">20.2 Extensions</a></li>
</ul>
</li>
<li><a href="#16-march">21 16 March</a><ul>
<li><a href="#type-inference-and-polymorphism">21.1 Type inference and polymorphism</a><ul>
<li><a href="#type-inference">21.1.1 Type inference</a></li>
<li><a href="#solving-constraints">21.1.2 Solving constraints</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#19-march">22 19 March</a><ul>
<li><a href="#type-inference_1">22.1 Type inference</a></li>
<li><a href="#unification-algorithm">22.2 Unification Algorithm</a></li>
<li><a href="#examples-part-2">22.3 Examples (part 2)</a></li>
</ul>
</li>
<li><a href="#21-march">23 21 March</a><ul>
<li><a href="#type-inference-continued">23.1 Type inference continued</a><ul>
<li><a href="#warm-up-examples">23.1.1 Warm-up examples</a></li>
<li><a href="#modifying-our-typing-rules">23.1.2 Modifying our typing rules</a></li>
<li><a href="#more-examples">23.1.3 More examples</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#23-march">24 23 March</a><ul>
<li><a href="#bi-directional-type-checking">24.1 Bi-directional type checking</a></li>
</ul>
</li>
<li><a href="#26-march">25 26 March</a><ul>
<li><a href="#subtyping">25.1 Subtyping</a><ul>
<li><a href="#function-example">25.1.1 Function example</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#28-march">26 28 March</a><ul>
<li><a href="#subtyping-continued">26.1 Subtyping continued</a><ul>
<li><a href="#review">26.1.1 Review</a></li>
<li><a href="#references">26.1.2 References</a></li>
<li><a href="#more-subtyping">26.1.3 More subtyping</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#30-march">27 30 March</a><ul>
<li><a href="#dependent-types">27.1 Dependent types</a></li>
</ul>
</li>
<li><a href="#02-april">28 02 April</a><ul>
<li><a href="#dependent-types-continued">28.1 Dependent Types continued</a></li>
</ul>
</li>
<li><a href="#04-april">29 04 April</a><ul>
<li><a href="#type-preserving-evaluator-with-agda">29.1 Type-Preserving Evaluator with Agda</a></li>
</ul>
</li>
<li><a href="#11-april">30 11 April</a><ul>
<li><a href="#object-oriented-vs-functional">30.1 Object-Oriented vs Functional</a><ul>
<li><a href="#classes-and-types">30.1.1 Classes and types</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#13-16-april">31 13 &amp; 16 April</a><ul>
<li><a href="#induction-proof-example">31.1 Induction Proof Example</a></li>
<li><a href="#backtracking">31.2 Backtracking</a><ul>
<li><a href="#with-exceptions">31.2.1 With Exceptions</a></li>
<li><a href="#with-continuations">31.2.2 With continuations</a></li>
</ul>
</li>
<li><a href="#environment-diagram">31.3 Environment Diagram</a></li>
</ul>
</li>
</ul>
</div>
<h2 class="header"><i>1</i>09 January<a class="headerlink" href="#09-january" name="09-january">&para;</a></h2>
<h3 class="header"><i>1.1</i>Introduction to Functional Programming in Standard ML<a class="headerlink" href="#introduction-to-functional-programming-in-standard-ml" name="introduction-to-functional-programming-in-standard-ml">&para;</a></h3>
<h4 class="header"><i>1.1.1</i>What are types?<a class="headerlink" href="#what-are-types" name="what-are-types">&para;</a></h4>
<p>Types classify terms (expressions) according to the properties of values.</p>
<div class="codehilite"><pre><span class="mi">4</span> <span class="p">:</span> <span class="n">int</span>
<span class="mi">~1</span> <span class="p">:</span> <span class="n">int</span>
<span class="mi">3</span><span class="n">+</span><span class="mi">2</span> <span class="p">:</span> <span class="n">int</span>
<span class="mi">5</span> <span class="n">div</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">int</span>
<span class="mf">3.0</span> <span class="p">:</span> <span class="n">real</span>
<span class="mf">3.0</span><span class="n">/</span><span class="mf">4.2</span> <span class="p">:</span> <span class="n">real</span>
<span class="mf">3.0</span> <span class="n">+</span> <span class="mf">4.2</span> <span class="p">:</span> <span class="n">real</span>
</pre></div>


<p>Here, notice that <code>+</code> is an overloaded operator that works with both ints and reals. The division operator is not, however, so SML will make a distinction between <code>div</code> for integer division and <code>/</code> for real division.</p>
<p>We cannot mix types in SML, e.g. <code>3.2 + 1</code> will return a type error.</p>
<div class="codehilite"><pre><span class="s2">&quot;abc&quot;</span> <span class="p">:</span> <span class="n">string</span>
<span class="sc">#&quot;a&quot;</span> <span class="p">:</span> <span class="n">character</span>
</pre></div>


<p>Types are a <em>static</em> approximation of the run-time behaviour of the program -- type checking is done <em>before</em> execution.</p>
<p>If-statements must have a boolean as the guard, and two possible branches must be <em>of the same type</em>. However, the type checker is not "smart".</p>
<div class="codehilite"><pre><span class="kr">if</span> <span class="n">true</span> <span class="kr">then</span> <span class="mf">3.0</span> <span class="kr">else</span> <span class="mf">4.2</span> <span class="p">:</span> <span class="n">real</span>
<span class="kr">if</span> <span class="n">false</span> <span class="kr">then</span> <span class="mi">4</span> <span class="kr">else</span> <span class="mi">1</span> <span class="n">div</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">int</span> <span class="cm">(* again, type checker is not smart *)</span>
<span class="kr">if</span> <span class="n">false</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="mf">2.0</span> <span class="cm">(* type error - branches do not agree on a type *)</span>
</pre></div>


<h2 class="header"><i>2</i>11 January<a class="headerlink" href="#11-january" name="11-january">&para;</a></h2>
<h3 class="header"><i>2.1</i>Bindings and scope of variables and functions<a class="headerlink" href="#bindings-and-scope-of-variables-and-functions" name="bindings-and-scope-of-variables-and-functions">&para;</a></h3>
<p><code>val pi = 3.14</code></p>
<p><strong>Binding:</strong> variable name paired with a value. Note that bindings are different than assignments found in imperative languages. </p>
<p>Local bindings:</p>
<div class="codehilite"><pre><span class="kr">let</span>
    <span class="kr">val</span> <span class="nv">m</span> <span class="p">=</span> <span class="mi">3</span>
    <span class="kr">val</span> <span class="nv">n</span> <span class="p">=</span> <span class="n">m*m</span>     <span class="cm">(* n=9 *)</span>
    <span class="kr">val</span> <span class="nv">k</span> <span class="p">=</span> <span class="n">m*m</span>     <span class="cm">(* k=9 *)</span>
<span class="kr">in</span>
    <span class="n">k*n</span>             <span class="cm">(* 81 *)</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>


<p>In the above example, <code>m,n,k</code> disappear after the <code>end</code> keyword. Notice that SML uses bindings, not assignments, so there exist some overshadowing issues to keep in mind:</p>
<div class="codehilite"><pre><span class="kr">val</span> <span class="nv">k</span> <span class="p">=</span> <span class="mi">4</span>
<span class="kr">let</span>
    <span class="kr">val</span> <span class="nv">k</span> <span class="p">=</span> <span class="mi">3</span>
<span class="kr">in</span>
    <span class="n">k*k</span>         <span class="cm">(* final value is 9, not 16 *)</span>
<span class="kr">end</span>
<span class="n">k</span>               <span class="cm">(* returns 4*)</span>
</pre></div>


<h3 class="header"><i>2.2</i>Functions<a class="headerlink" href="#functions" name="functions">&para;</a></h3>
<p>Functions in SML (and all functional languages, by definition) are <em>values</em>.</p>
<div class="codehilite"><pre><span class="cm">(* area : real -&gt; real *)</span>
<span class="kr">val</span> <span class="nv">area</span> <span class="p">=</span> <span class="kr">fun</span> <span class="nf">r</span> <span class="p">=&gt;</span> <span class="n">pi</span> <span class="n">*</span> <span class="n">r</span> <span class="n">*</span> <span class="n">r</span>
<span class="cm">(* or, equivalently and more compactly: *)</span>
<span class="kr">fun</span> <span class="nf">area</span> <span class="n">r</span> <span class="p">=</span> <span class="n">pi</span> <span class="n">*</span> <span class="n">r</span> <span class="n">*</span> <span class="n">r</span>
<span class="cm">(* to explicitly restrict a type: *)</span>
<span class="kr">fun</span> <span class="nf">sqr</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="n">real</span><span class="p">)</span> <span class="p">=</span> <span class="n">x</span> <span class="n">*</span> <span class="n">x</span>
<span class="cm">(* using one parameter *)</span>
<span class="kr">fun</span> <span class="nf">add</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="n">real</span><span class="p">,</span> <span class="n">y</span> <span class="p">:</span> <span class="n">real</span><span class="p">)</span> <span class="p">=</span> <span class="n">x</span> <span class="n">+</span> <span class="n">y</span>
</pre></div>


<p>Functions use the values of the most recent binding of the variables within themselves. For example:</p>
<div class="codehilite"><pre><span class="kr">val</span> <span class="nv">a2</span> <span class="p">=</span> <span class="n">area</span> <span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>     <span class="cm">(* 12.56 *)</span>
<span class="kr">val</span> <span class="nv">pi</span><span class="p">=</span> <span class="mf">6.0</span>
<span class="kr">val</span> <span class="nv">a3</span> <span class="p">=</span> <span class="n">area</span> <span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>     <span class="cm">(* still 12.56 *)</span>
</pre></div>


<p>In order to update functions, you must re-declare the function to overshadow the previous binding.</p>
<p>The structure of the input of functions is important!</p>
<div class="codehilite"><pre><span class="cm">(* add : int -&gt; int -&gt; int *)</span>
<span class="n">add</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="n">int</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span> <span class="p">:</span> <span class="n">int</span><span class="p">)</span> <span class="p">=</span> <span class="n">x</span> <span class="n">+</span> <span class="n">y</span>
<span class="cm">(* add&#39; : (int * int) -&gt; int *)</span>
<span class="n">add&#39;</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="n">int</span><span class="p">,</span> <span class="n">y</span> <span class="p">:</span> <span class="n">int</span><span class="p">)</span> <span class="p">=</span> <span class="n">x</span> <span class="n">+</span> <span class="n">y</span>
</pre></div>


<p>The function <code>add'</code> takes in one argument -- a tuple with two elements -- whereas <code>add</code> takes in two separate arguments.</p>
<h3 class="header"><i>2.3</i>Recursion in SML<a class="headerlink" href="#recursion-in-sml" name="recursion-in-sml">&para;</a></h3>
<div class="codehilite"><pre><span class="kr">exception</span> <span class="nc">Domain</span>
<span class="kr">fun</span> <span class="nf">fact</span> <span class="n">n</span> <span class="p">=</span>
    <span class="kr">let</span>
        <span class="kr">fun</span> <span class="nf">fact&#39;</span> <span class="mi">0</span> <span class="p">=</span> <span class="mi">1</span>
          <span class="p">|</span> <span class="nf">fact&#39;</span> <span class="n">n</span> <span class="p">=</span> <span class="n">n</span> <span class="n">*</span> <span class="n">fact&#39;</span> <span class="p">(</span><span class="n">n-</span><span class="mi">1</span><span class="p">)</span>
    <span class="kr">in</span>
        <span class="kr">if</span> <span class="n">n</span> <span class="n">&gt;=</span> <span class="mi">0</span> <span class="kr">then</span>
           <span class="n">fact&#39;</span> <span class="n">n</span>
        <span class="kr">else</span>
           <span class="kr">raise</span> <span class="n">Domain</span>
    <span class="kr">end</span>
</pre></div>


<p>Note that the above method is nowhere near the most efficient way of expressing the factorial function, but it works as an example of recursion in this case.</p>
<h2 class="header"><i>3</i>13 Jan<a class="headerlink" href="#13-jan" name="13-jan">&para;</a></h2>
<h3 class="header"><i>3.1</i>Data types<a class="headerlink" href="#data-types" name="data-types">&para;</a></h3>
<p>We can define our own datatypes using the <code>datatype</code> keyword:</p>
<div class="codehilite"><pre><span class="kr">datatype</span> <span class="kt">Suit</span> <span class="p">=</span> <span class="nc">Hearts</span> <span class="p">|</span> <span class="nc">Diamonds</span> <span class="p">|</span> <span class="nc">Spades</span> <span class="p">|</span> <span class="nc">Clubs</span>
<span class="cm">(* dom : suit * suit -&gt; bool, where spades &gt; hearts &gt; diamonds &gt; clubs *)</span>
<span class="kr">fun</span> <span class="nf">dom</span> <span class="p">(</span><span class="n">Spades</span><span class="p">,</span> <span class="p">_)</span> <span class="p">=</span> <span class="n">true</span>
  <span class="p">|</span> <span class="nf">dom</span> <span class="p">(_,</span> <span class="n">Clubs</span><span class="p">)</span> <span class="p">=</span> <span class="n">true</span>
  <span class="p">|</span> <span class="nf">dom</span> <span class="p">(</span><span class="n">Hearts</span><span class="p">,</span> <span class="n">Diamonds</span><span class="p">)</span> <span class="p">=</span> <span class="n">true</span>
  <span class="p">|</span> <span class="nf">dom</span> <span class="p">(</span><span class="n">S1</span><span class="p">,</span> <span class="n">S2</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="n">S1</span> <span class="p">=</span> <span class="n">S2</span><span class="p">)</span>
</pre></div>


<p>SML will warn you if your pattern-matching does not cover all possible cases.</p>
<div class="codehilite"><pre><span class="kr">datatype</span> <span class="kt">rank</span> <span class="p">=</span> <span class="nc">Ace</span> <span class="p">|</span> <span class="nc">King</span> <span class="p">|</span> <span class="nc">Queen</span> <span class="p">|</span> <span class="nc">Jack</span> <span class="p">|</span> <span class="nc">Ten</span> <span class="n">|</span> <span class="p">...</span>
<span class="kr">type</span> <span class="kt">card</span> <span class="p">=</span> <span class="n">rank</span> <span class="n">*</span> <span class="n">suit</span>     
<span class="cm">(* instead of declaring a tuple every time, we can use this &quot;abbreviation&quot; *)</span>
<span class="kr">val</span> <span class="nv">c0</span> <span class="p">=</span> <span class="p">(</span><span class="n">Queen</span><span class="p">,</span> <span class="n">Hearts</span><span class="p">)</span>
</pre></div>


<p>The above are examples of finite data types. </p>
<p>Mathematically, a hand can be either empty, or, if <span>$C$</span> is a card and <span>$H$</span> is a hand, <code>Hand(C,H)</code> (this is an example of a constructor).</p>
<div class="codehilite"><pre><span class="kr">datatype</span> <span class="kt">hand</span> <span class="p">=</span> <span class="nc">Empty</span> <span class="p">|</span> <span class="nc">Hand</span> <span class="kr">of</span> <span class="n">Card</span> <span class="n">*</span> <span class="n">Hand</span>
<span class="kr">val</span> <span class="nv">h0</span> <span class="p">=</span> <span class="n">Empty</span>
<span class="kr">val</span> <span class="nv">h1</span> <span class="p">=</span> <span class="n">Hand</span> <span class="p">(</span><span class="n">c0</span><span class="p">,</span> <span class="n">h0</span><span class="p">)</span>
<span class="kr">val</span> <span class="nv">h2</span> <span class="p">=</span> <span class="n">Hand</span> <span class="p">((</span><span class="n">King</span><span class="p">,</span> <span class="n">Clubs</span><span class="p">),</span> <span class="n">h1</span><span class="p">)</span>

<span class="cm">(* count : hand -&gt; int *)</span>
<span class="kr">fun</span> <span class="nf">count</span> <span class="n">Empty</span> <span class="p">=</span> <span class="mi">0</span>
  <span class="p">|</span> <span class="nf">count</span> <span class="p">(</span><span class="n">Hand</span> <span class="p">(_,</span> <span class="n">h</span><span class="p">))</span> <span class="p">=</span> <span class="mi">1</span> <span class="n">+</span> <span class="n">count</span> <span class="n">h</span>
</pre></div>


<p>What about infinite data types?</p>
<h4 class="header"><i>3.1.1</i>Lists in SML<a class="headerlink" href="#lists-in-sml" name="lists-in-sml">&para;</a></h4>
<p>Lists are an example of an incredibly useful datatype found in SML's base language.</p>
<p>A list is either empty (nil) or, if <span>$A$</span> is an element and <span>$L$</span> is a list, <code>Cons(A,L)</code>.</p>
<p>Note here that <code>'a</code> (pronounced "alpha", for <span>$\alpha$</span>) is a type variable for all possible types. This allows us to create polymorphic data types.</p>
<div class="codehilite"><pre><span class="kr">datatype</span> <span class="nd">&#39;a</span> <span class="kt">list</span> <span class="p">=</span> <span class="nc">Nil</span> <span class="p">|</span> <span class="nc">Cons</span> <span class="kr">of</span> <span class="nd">&#39;a</span> <span class="n">*</span> <span class="nd">&#39;a</span> <span class="n">list</span>
<span class="kr">val</span> <span class="nv">l1</span> <span class="p">=</span> <span class="n">Cons</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nil</span><span class="p">)</span>      <span class="cm">(* : int list  *)</span>
<span class="kr">val</span> <span class="nv">l2</span> <span class="p">=</span> <span class="n">Cons</span> <span class="p">(</span><span class="n">Queen</span><span class="p">,</span> <span class="n">Nil</span><span class="p">)</span>  <span class="cm">(* : rank list *)</span>
</pre></div>


<p>Lists are already defined in SML with a convenient syntax:</p>
<div class="codehilite"><pre><span class="n">nil</span>         <span class="cm">(* empty list *)</span>
<span class="p">[]</span> <span class="p">=</span> <span class="n">nil</span>
<span class="p">_</span><span class="n">::</span><span class="p">_</span>        <span class="cm">(* infix/cons operator *)</span>
<span class="mi">1</span><span class="n">::nil</span><span class="p">,</span> <span class="mi">1</span><span class="n">::</span><span class="mi">2</span><span class="n">::</span><span class="mi">3</span><span class="n">::</span><span class="p">[]</span>
</pre></div>


<p>All elements of a list must be of the same type. You can get around this by defining a new data type with the option of storing multiple values, if need be.</p>
<h2 class="header"><i>4</i>16 January<a class="headerlink" href="#16-january" name="16-january">&para;</a></h2>
<h3 class="header"><i>4.1</i>Datatypes continued<a class="headerlink" href="#datatypes-continued" name="datatypes-continued">&para;</a></h3>
<div class="codehilite"><pre><span class="kr">datatype</span> <span class="nd">&#39;a</span> <span class="kt">option</span> <span class="p">=</span> <span class="nc">None</span> <span class="p">|</span> <span class="nc">Some</span> <span class="kr">of</span> <span class="nd">&#39;a</span>
<span class="cm">(* hd : &#39;a list -&gt; &#39;a option *)</span>
<span class="kr">fun</span> <span class="nf">hd</span> <span class="p">(</span><span class="n">h::</span><span class="p">_)</span> <span class="p">=</span> <span class="n">Some</span> <span class="n">h</span>
  <span class="p">|</span> <span class="nf">hd</span> <span class="p">[]</span> <span class="p">=</span> <span class="n">None</span>

<span class="cm">(* naive append function *)</span>
<span class="cm">(* app: (&#39;a list * &#39;a list) -&gt; &#39;a list *)</span>
<span class="kr">fun</span> <span class="nf">app</span> <span class="p">([],</span> <span class="n">l2</span><span class="p">)</span> <span class="p">=</span> <span class="n">l2</span>
  <span class="p">|</span> <span class="nf">app</span> <span class="p">(</span><span class="n">h::t</span><span class="p">,</span> <span class="n">l2</span><span class="p">)</span> <span class="p">=</span> <span class="n">h::</span><span class="p">(</span><span class="n">app</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">l2</span><span class="p">))</span>
<span class="cm">(* @ is the built-in append operator in SML *)</span>

<span class="cm">(* rev : &#39;a list -&gt; &#39;a list *)</span>
<span class="kr">fun</span> <span class="nf">rev</span> <span class="p">[]</span> <span class="p">=</span> <span class="p">[]</span>
  <span class="p">|</span> <span class="nf">rev</span> <span class="p">(</span><span class="n">h::t</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="n">rev</span> <span class="n">t</span><span class="p">)</span> <span class="n">@</span> <span class="p">[</span><span class="n">h</span><span class="p">]</span>
<span class="cm">(* this is O(n^2) in time because of the append operator *)</span>

<span class="cm">(* using tail-recursion in O(n) time*)</span>
<span class="kr">fun</span> <span class="nf">rev_tl</span> <span class="n">l</span> <span class="p">=</span>
    <span class="kr">let</span>
        <span class="kr">fun</span> <span class="nf">rev</span> <span class="p">([],</span> <span class="n">acc</span><span class="p">)</span> <span class="p">=</span> <span class="n">acc</span>
          <span class="p">|</span> <span class="nf">rev</span> <span class="p">(</span><span class="n">h::t</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="p">=</span> <span class="n">rev</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">h::acc</span><span class="p">)</span>
    <span class="kr">in</span>
        <span class="n">rev</span> <span class="p">(</span><span class="n">l</span><span class="p">,[])</span>
    <span class="kr">end</span>
</pre></div>


<p>A binary tree is either empty or, if L and R are binary trees and v is a value of type <span>$\alpha$</span>, <code>Node(v,L,R)</code>.</p>
<div class="codehilite"><pre><span class="kr">datatype</span> <span class="nd">&#39;a</span> <span class="kt">tree</span> <span class="p">=</span> <span class="nc">Empty</span> <span class="p">|</span> <span class="nc">Node</span> <span class="kr">of</span> <span class="nd">&#39;a</span> <span class="n">*</span> <span class="nd">&#39;a</span> <span class="n">tree</span> <span class="n">*</span> <span class="nd">&#39;a</span> <span class="n">tree</span>

<span class="cm">(* size : &#39;a tree -&gt; int *)</span>
<span class="kr">fun</span> <span class="nf">size</span> <span class="n">Empty</span> <span class="p">=</span> <span class="mi">0</span>
  <span class="p">|</span> <span class="nf">size</span> <span class="p">(</span><span class="n">Node</span><span class="p">(_,</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">))</span> <span class="p">=</span> <span class="n">size</span> <span class="n">L</span> <span class="n">+</span> <span class="n">size</span> <span class="n">R</span> <span class="n">+</span> <span class="mi">1</span>
<span class="cm">(* insert: (int * &#39;a) -&gt; (int * &#39;a) tree -&gt; (int * &#39;a) tree *)</span>
<span class="kr">fun</span> <span class="nf">insert</span> <span class="n">e</span> <span class="n">Empty</span> <span class="p">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Empty</span><span class="p">,</span> <span class="n">Empty</span><span class="p">)</span>
  <span class="p">|</span> <span class="nf">insert</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="kr">as</span> <span class="n">e</span><span class="p">)(</span><span class="n">Node</span><span class="p">((</span><span class="n">y</span><span class="p">,</span><span class="n">d&#39;</span><span class="p">),</span><span class="n">L</span><span class="p">,</span><span class="n">R</span><span class="p">))</span> <span class="p">=</span>
        <span class="kr">if</span> <span class="n">x</span><span class="p">=</span><span class="n">y</span> <span class="kr">then</span> <span class="n">Node</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">R</span><span class="p">)</span>
        <span class="kr">else</span>
            <span class="kr">if</span> <span class="n">x&lt;y</span> <span class="kr">then</span> <span class="n">Node</span><span class="p">((</span><span class="n">y</span><span class="p">,</span><span class="n">d&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">insert</span> <span class="n">e</span> <span class="n">L</span><span class="p">),</span> <span class="n">R</span><span class="p">)</span>
            <span class="kr">else</span> <span class="n">Node</span><span class="p">((</span><span class="n">y</span><span class="p">,</span><span class="n">d&#39;</span><span class="p">),</span> <span class="n">L</span><span class="p">,</span> <span class="p">(</span><span class="n">insert</span> <span class="n">e</span> <span class="n">R</span><span class="p">))</span>
</pre></div>


<h2 class="header"><i>5</i>18 &amp; 20 January<a class="headerlink" href="#18-20-january" name="18-20-january">&para;</a></h2>
<h3 class="header"><i>5.1</i>Mathematical Induction<a class="headerlink" href="#mathematical-induction" name="mathematical-induction">&para;</a></h3>
<p>See induction pdf.</p>
<h2 class="header"><i>6</i>23 January<a class="headerlink" href="#23-january" name="23-january">&para;</a></h2>
<h3 class="header"><i>6.1</i>Higher-Order Functions<a class="headerlink" href="#higher-order-functions" name="higher-order-functions">&para;</a></h3>
<p>Functions as values -- can pass to functions or return as results! This allows us to create modular, reusable code.</p>
<div class="codehilite"><pre><span class="kr">fun</span> <span class="nf">sumInts</span>  <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">=</span> <span class="kr">if</span> <span class="n">a&gt;b</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> <span class="n">a</span>       <span class="n">+</span> <span class="n">sumInts</span>  <span class="p">(</span><span class="n">a+</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="kr">fun</span> <span class="nf">sumSqrs</span>  <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">=</span> <span class="kr">if</span> <span class="n">a&gt;b</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> <span class="p">(</span><span class="n">a*a</span><span class="p">)</span>   <span class="n">+</span> <span class="n">sumSq</span>    <span class="p">(</span><span class="n">a+</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="kr">fun</span> <span class="nf">sumCubes</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">=</span> <span class="kr">if</span> <span class="n">a&gt;b</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> <span class="p">(</span><span class="n">a*a*a</span><span class="p">)</span> <span class="n">+</span> <span class="n">sumCubes</span> <span class="p">(</span><span class="n">a+</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="cm">(* etc. *)</span>
</pre></div>


<p>The above code is not very clean or reusable -- what if we wanted to sum the powers of 100? We want to abstract what we're doing.</p>
<div class="codehilite"><pre><span class="cm">(* sum : (int -&gt; int) * int * int -&gt; int *)</span>
<span class="n">sum</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">=</span> <span class="kr">if</span> <span class="n">a</span> <span class="n">&gt;</span> <span class="n">b</span> <span class="kr">then</span> <span class="mi">0</span>
              <span class="kr">else</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="n">+</span> <span class="p">(</span><span class="n">sum</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">a+</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>

<span class="kr">fun</span> <span class="nf">sq</span> <span class="n">x</span> <span class="p">=</span> <span class="n">x*x</span>
<span class="kr">fun</span> <span class="nf">sumSq</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">=</span> <span class="n">sum</span> <span class="p">(</span><span class="n">sq</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="kr">fun</span> <span class="nf">id</span> <span class="n">x</span> <span class="p">=</span> <span class="n">x</span>
<span class="kr">fun</span> <span class="nf">sumInts</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">=</span> <span class="n">sum</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>


<p>It's a bit silly to give all these functions names, so we can define functions "on the fly" without giving them names:</p>
<div class="codehilite"><pre><span class="kr">fun</span> <span class="nf">sumInts</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">=</span> <span class="n">sum</span> <span class="p">((</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">),</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="kr">val</span> <span class="nv">id</span> <span class="p">=</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">)</span>
<span class="kr">fun</span> <span class="nf">sumSq</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">=</span> <span class="n">sum</span> <span class="p">((</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x*x</span><span class="p">),</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>


<p>Our only real restriction on anonymous functions is that they cannot be recursive, since you need to give names to recursive functions to call them.</p>
<div class="codehilite"><pre><span class="kr">fun</span> <span class="nf">inc</span> <span class="p">[]</span> <span class="p">=</span> <span class="n">Empty</span>
  <span class="p">|</span> <span class="nf">inc</span> <span class="p">(</span><span class="n">h::t</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="n">h+</span><span class="mi">1</span><span class="p">)</span><span class="n">::</span><span class="p">(</span><span class="n">inc</span> <span class="n">t</span><span class="p">)</span>
<span class="cm">(* What if we wanted to multiply each element? Square each element? *)</span>

<span class="kr">fun</span> <span class="nf">map</span> <span class="n">f</span> <span class="p">[]</span> <span class="p">=</span> <span class="p">[]</span>
  <span class="p">|</span> <span class="nf">map</span> <span class="n">f</span> <span class="p">(</span><span class="n">h::t</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="n">f</span> <span class="n">h</span><span class="p">)</span><span class="n">::</span><span class="p">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">t</span><span class="p">)</span>

<span class="cm">(* filter out all elements which are, say, even *)</span>
<span class="kr">fun</span> <span class="nf">filterEven</span> <span class="p">[]</span> <span class="p">=</span> <span class="n">Empty</span>
  <span class="p">|</span> <span class="nf">filterEven</span> <span class="p">(</span><span class="n">h::t</span><span class="p">)</span> <span class="p">=</span> <span class="kr">if</span> <span class="n">h</span> <span class="n">mod</span> <span class="mi">2</span> <span class="p">=</span> <span class="mi">0</span> <span class="kr">then</span> <span class="n">h::filterEven</span> <span class="n">t</span> <span class="kr">else</span> <span class="n">filterEven</span> <span class="n">t</span>

<span class="cm">(* filter : (&#39;a -&gt; bool) -&gt; &#39;a list -&gt; &#39;a list *)</span>
<span class="kr">fun</span> <span class="nf">filter</span> <span class="n">f</span> <span class="p">[]</span> <span class="p">=</span> <span class="p">[]</span>
  <span class="p">|</span> <span class="nf">filter</span> <span class="n">f</span> <span class="p">(</span><span class="n">h::t</span><span class="p">)</span> <span class="p">=</span> <span class="kr">if</span> <span class="n">f</span> <span class="n">h</span> <span class="kr">then</span> <span class="n">h::filter</span> <span class="n">t</span> <span class="kr">else</span> <span class="n">filter</span> <span class="n">t</span>
</pre></div>


<h2 class="header"><i>7</i>25 &amp; 30 January<a class="headerlink" href="#25-30-january" name="25-30-january">&para;</a></h2>
<p>These two lectures were taught by a TA, and cover higher-order functions, currying, and staging evaluation. The material can be found in the relevant pdfs.</p>
<p>Link to PDF: <a href="http://cs.mcgill.ca/~cs302/handouts/hofun.pdf">http://cs.mcgill.ca/~cs302/handouts/hofun.pdf</a></p>
<h2 class="header"><i>8</i>03 February<a class="headerlink" href="#03-february" name="03-february">&para;</a></h2>
<p>Continuations</p>
<h3 class="header"><i>8.1</i>Regular Expression Matching<a class="headerlink" href="#regular-expression-matching" name="regular-expression-matching">&para;</a></h3>
<p>Typical patterns:</p>
<ul>
<li>Singleton: matching a specific character</li>
<li>Alternation: choice between two patterns</li>
<li>Concatenation: succession of patterns</li>
<li>Iteration: repeat a certain pattern (indefinite)</li>
</ul>
<p>Regular expressions;</p>
<ul>
<li>0 and 1 are regular expressions.</li>
<li>If <span>$a \in \Sigma$</span> where <span>$\Sigma$</span> is an alphabet, then <span>$a$</span> is a regular expression.</li>
<li>If <span>$r_1$</span> and <span>$r_2$</span> are regular expressions, then <span>$r_1 + r_2$</span> (choice) and <span>$r_{1}r_{2}$</span> (concatenation) are regular expressions.</li>
<li>If r is a regular expression, then <span>$r^*$</span> is a regular expression (repetition).</li>
</ul>
<p>Examples;</p>
<ul>
<li><code>a(p*)l(e+y)</code> matches against "apple", "apply", "ale"</li>
<li><code>g(1+r)(e+a)y</code> matches against "grey", "gray", "gey", "gay" (<code>1</code> means you can either have something there or not)</li>
<li><code>g(1+o)*gle</code> matches "google", "ggle"</li>
</ul>
<p>Our goal is to implement a regex matcher in SML.</p>
<p>Regular expression algorithm:</p>
<div class="codehilite"><pre><span class="n">s</span> <span class="n">matches</span> <span class="mi">1</span>
  <span class="n">iff</span> <span class="n">s</span> <span class="n">is</span> <span class="n">empty</span>
<span class="n">s</span> <span class="n">matches</span> <span class="n">a</span>
  <span class="n">iff</span> <span class="n">s</span> <span class="p">=</span> <span class="n">a</span>
<span class="n">s</span> <span class="n">matches</span> <span class="n">r1+r2</span>
  <span class="n">iff</span> <span class="n">either</span> <span class="n">s</span> <span class="n">matches</span> <span class="n">r1</span>
          <span class="n">or</span> <span class="n">s</span> <span class="n">matches</span> <span class="n">r2</span>
<span class="n">s</span> <span class="n">matches</span> <span class="n">r1r2</span>
  <span class="n">iff</span> <span class="n">s</span> <span class="p">=</span> <span class="n">s1s2</span> <span class="kr">and</span> <span class="nv">s1</span> <span class="n">matches</span> <span class="n">r1</span>
               <span class="kr">and</span> <span class="nv">s2</span> <span class="n">matches</span> <span class="n">r2</span>
<span class="n">s</span> <span class="n">matches</span> <span class="n">r*</span>
  <span class="n">iff</span> <span class="n">either</span> <span class="n">s</span> <span class="n">is</span> <span class="n">empty</span>
          <span class="n">or</span> <span class="n">s</span> <span class="p">=</span> <span class="n">s1s2</span> <span class="kr">where</span> <span class="n">s1</span> <span class="n">matches</span> <span class="n">r</span>
                        <span class="kr">and</span> <span class="nv">s2</span> <span class="n">matches</span> <span class="n">r*</span>
</pre></div>


<p>Remember that continuations tell us what to do once an initial segment of the input <code>char list</code> has been matched.</p>
<p>In SML, using continuations:</p>
<div class="codehilite"><pre><span class="kr">datatype</span> <span class="kt">regexp</span> <span class="p">=</span> <span class="nc">Zero</span> <span class="p">|</span> <span class="nc">One</span> <span class="p">|</span> <span class="nc">Char</span> <span class="kr">of</span> <span class="n">char</span> <span class="p">|</span> <span class="nc">Plus</span> <span class="kr">of</span> <span class="n">regexp</span> <span class="n">*</span> <span class="n">regexp</span>
                <span class="p">|</span> <span class="nc">Times</span> <span class="kr">of</span> <span class="n">regexp*regexp</span> <span class="p">|</span> <span class="nc">Star</span> <span class="kr">of</span> <span class="n">regexp</span>

<span class="cm">(* acc r s cont = bool *)</span>
<span class="cm">(* acc: regexp -&gt; char list -&gt; (char list -&gt; bool) -&gt; bool *)</span>
<span class="cm">(* ex: a(p*)</span><span class="n">l</span><span class="p">(</span><span class="n">e+y</span><span class="p">)</span> <span class="n">on</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">e</span><span class="p">]</span> <span class="n">*</span><span class="p">)</span>
<span class="kr">fun</span> <span class="nf">acc</span> <span class="p">(</span><span class="n">Char</span> <span class="n">c</span><span class="p">)</span> <span class="p">[]</span> <span class="n">cont</span> <span class="p">=</span> <span class="n">false</span>
  <span class="p">|</span> <span class="nf">acc</span> <span class="p">(</span><span class="n">Char</span> <span class="n">c</span><span class="p">)</span> <span class="p">(</span><span class="n">c1::s</span><span class="p">)</span> <span class="n">cont</span> <span class="p">=</span> 
        <span class="n">c</span> <span class="p">=</span> <span class="n">c1</span> <span class="kr">andalso</span> <span class="p">(</span><span class="n">cont</span> <span class="n">s</span><span class="p">)</span>
  <span class="p">|</span> <span class="nf">acc</span> <span class="p">(</span><span class="n">Times</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">))</span> <span class="n">s</span> <span class="n">cont</span> <span class="p">=</span>
        <span class="n">acc</span> <span class="n">r1</span> <span class="n">s</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">s2</span> <span class="p">=&gt;</span> <span class="n">acc</span> <span class="n">r2</span> <span class="n">s2</span> <span class="n">cont</span><span class="p">)</span>
  <span class="p">|</span> <span class="nf">acc</span> <span class="p">(</span><span class="n">Plus</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">)</span> <span class="n">s</span> <span class="n">cont</span> <span class="p">=</span>
        <span class="n">acc</span> <span class="n">r1</span> <span class="n">s</span> <span class="n">cont</span> <span class="kr">orelse</span> <span class="n">acc</span> <span class="n">r2</span> <span class="n">s</span> <span class="n">cont</span>
  <span class="n">|</span> <span class="n">acc</span> <span class="n">One</span> <span class="n">s</span> <span class="n">cont</span> <span class="p">=</span> <span class="n">cont</span> <span class="n">s</span>
  <span class="n">|</span> <span class="n">acc</span> <span class="p">(</span><span class="n">Star</span> <span class="n">r</span><span class="p">)</span> <span class="n">s</span> <span class="n">cont</span> <span class="p">=</span> 
        <span class="cm">(* remove (1*)</span> <span class="kr">case</span> <span class="n">-</span> <span class="n">s</span> <span class="n">must</span> <span class="n">shrink</span> <span class="n">*</span><span class="p">)</span>
        <span class="p">(</span><span class="n">cont</span> <span class="n">s</span><span class="p">)</span> <span class="kr">orelse</span>
              <span class="n">acc</span> <span class="n">r</span> <span class="n">s</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">s&#39;</span> <span class="p">=&gt;</span> <span class="n">not</span> <span class="p">(</span><span class="n">s</span> <span class="p">=</span> <span class="n">s&#39;</span><span class="p">)</span> <span class="kr">orelse</span> 
                                    <span class="n">acc</span> <span class="p">(</span><span class="n">Star</span> <span class="n">r</span><span class="p">)</span> <span class="n">s&#39;</span> <span class="n">cont</span><span class="p">)</span>
</pre></div>


<h2 class="header"><i>9</i>6 February<a class="headerlink" href="#6-february" name="6-february">&para;</a></h2>
<h3 class="header"><i>9.1</i>Exceptions<a class="headerlink" href="#exceptions" name="exceptions">&para;</a></h3>
<p>We use exceptions to quit out from the runtime stack. We have already seen some built-in exceptions - for example, SML will throw a <code>Div</code> exception if you try to divide by zero (like <code>3 div 0</code>). Exceptions like this are used to abort a program safely whenever invalid input is given.</p>
<div class="codehilite"><pre><span class="cm">(* define the exception *)</span>
<span class="kr">exception</span> <span class="nc">Error</span> <span class="kr">of</span> <span class="n">String</span><span class="p">;</span>

<span class="kr">fun</span> <span class="nf">fact</span> <span class="n">n</span> <span class="p">=</span>
    <span class="kr">let</span> <span class="kr">fun</span> <span class="nf">fact&#39;</span> <span class="n">n</span> <span class="p">=</span>
        <span class="kr">if</span> <span class="n">n</span> <span class="p">=</span> <span class="mi">0</span> <span class="kr">then</span> <span class="mi">1</span>
        <span class="kr">else</span> <span class="n">n</span> <span class="n">*</span> <span class="n">fact&#39;</span><span class="p">(</span><span class="n">n-</span><span class="mi">1</span><span class="p">)</span>
    <span class="kr">in</span>
        <span class="kr">if</span> <span class="n">n</span> <span class="n">&lt;</span> <span class="mi">0</span> <span class="kr">then</span> <span class="kr">raise</span> <span class="n">Error</span> <span class="s2">&quot;Invalid Input&quot;</span>
        <span class="kr">else</span> <span class="n">fact&#39;</span> <span class="n">n</span>
    <span class="kr">end</span><span class="p">;</span>

<span class="cm">(* non-exhaustive warning *)</span>
<span class="kr">fun</span> <span class="nf">head</span> <span class="p">(</span><span class="n">h::</span><span class="p">_)</span> <span class="p">=</span> <span class="n">h</span><span class="p">;</span>
<span class="cm">(* uncaught exception Match *)</span>
<span class="n">head</span> <span class="p">[];</span> 
</pre></div>


<p>Sometimes we want to handle exceptions:</p>
<div class="codehilite"><pre><span class="cm">(* runFact: int -&gt; unit *)</span>
<span class="kr">fun</span> <span class="nf">runFact</span> <span class="n">n</span> <span class="p">=</span>
    <span class="kr">let</span> <span class="kr">val</span> <span class="nv">r</span> <span class="p">=</span> <span class="n">fact</span> <span class="n">n</span>
    <span class="kr">in</span> <span class="n">print</span> <span class="p">(</span><span class="s2">&quot;Factorial of &quot;</span> <span class="n">^</span> <span class="nn">Int</span><span class="p">.</span><span class="n">toString</span> <span class="n">n</span> <span class="n">^</span> <span class="s2">&quot; is &quot;</span> <span class="n">^</span> <span class="nn">Int</span><span class="p">.</span><span class="n">toString</span> <span class="n">r</span><span class="p">)</span>
    <span class="kr">end</span>
    <span class="kr">handle</span> <span class="n">Error</span> <span class="n">msg</span> <span class="p">=&gt;</span> <span class="n">print</span> <span class="p">(</span><span class="s2">&quot;Error: &quot;</span> <span class="n">^</span> <span class="n">msg</span><span class="p">)</span>
</pre></div>


<p>To sequentialize expressions, use the <code>;</code> operator. <code>exp1;exp2</code> first executes <code>exp1</code> then executes <code>exp2</code>. This is equivalent to <code>(fn x =&gt; exp2) exp1</code>. This will be expanded upon in the next lecture.</p>
<p>We can pattern match on error codes:</p>
<div class="codehilite"><pre><span class="cm">(* define the exception *)</span>
<span class="kr">exception</span> <span class="nc">Error</span> <span class="kr">of</span> <span class="n">int</span><span class="p">;</span>

<span class="kr">fun</span> <span class="nf">fact</span> <span class="n">n</span> <span class="p">=</span>
    <span class="kr">let</span> <span class="kr">fun</span> <span class="nf">fact&#39;</span> <span class="n">n</span> <span class="p">=</span>
            <span class="kr">if</span> <span class="n">n</span> <span class="p">=</span> <span class="mi">0</span> <span class="kr">then</span> <span class="mi">1</span>
    <span class="kr">else</span> <span class="n">n</span> <span class="n">*</span> <span class="n">fact&#39;</span><span class="p">(</span><span class="n">n-</span><span class="mi">1</span><span class="p">)</span>
    <span class="kr">in</span>
        <span class="kr">if</span> <span class="n">n</span> <span class="n">&lt;</span> <span class="mi">0</span> <span class="kr">then</span> <span class="kr">raise</span> <span class="n">Error</span> <span class="mi">00</span>
        <span class="kr">else</span> <span class="n">fact&#39;</span> <span class="n">n</span>
    <span class="kr">end</span><span class="p">;</span>

<span class="kr">fun</span> <span class="nf">runFact</span> <span class="n">n</span> <span class="p">=</span>
    <span class="kr">let</span> <span class="kr">val</span> <span class="nv">r</span> <span class="p">=</span> <span class="n">fact</span> <span class="n">n</span>
    <span class="kr">in</span> 
       <span class="n">print</span> <span class="p">(</span><span class="s2">&quot;Factorial of &quot;</span> <span class="n">^</span> <span class="nn">Int</span><span class="p">.</span><span class="n">toString</span> <span class="n">n</span> <span class="n">^</span> <span class="s2">&quot; is &quot;</span> <span class="n">^</span> <span class="nn">Int</span><span class="p">.</span><span class="n">toString</span> <span class="n">r</span><span class="p">)</span>
    <span class="kr">end</span>
    <span class="kr">handle</span> <span class="n">Error</span> <span class="mi">00</span> <span class="p">=&gt;</span> <span class="n">print</span> <span class="p">(</span><span class="s2">&quot;invalid input&quot;</span><span class="p">)</span>
         <span class="n">|</span> <span class="n">Error</span> <span class="mi">11</span> <span class="p">=&gt;</span> <span class="n">print</span> <span class="p">(</span><span class="s2">&quot;blah&quot;</span><span class="p">)</span>
         <span class="n">|</span> <span class="n">Error</span> <span class="p">_</span> <span class="p">=&gt;</span> <span class="n">print</span> <span class="p">(</span><span class="s2">&quot;Something else&quot;</span><span class="p">)</span>
</pre></div>


<p>Exceptions cannot be polymorphic, e.g. it cannot be of type <code>'a list</code> but can be of type <code>int list</code>.</p>
<p>Exceptions are usually pretty powerful in managing runtime stacks, but usually continuations are more powerful.</p>
<div class="codehilite"><pre><span class="cm">(* first arg: list of coins, second: what we want to get change for *)</span>
<span class="n">change</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="mi">43</span><span class="p">;</span>
<span class="cm">(* result:  [25,10,5,2,1] *)</span>

<span class="kr">exception</span> <span class="nc">Change</span> 
<span class="cm">(* change: int list -&gt; int -&gt; int list *)</span>

<span class="kr">fun</span> <span class="nf">change</span> <span class="p">_</span> <span class="mi">0</span> <span class="p">=</span> <span class="p">[]</span>
  <span class="p">|</span> <span class="nf">change</span> <span class="p">[]</span> <span class="n">amt</span> <span class="p">=</span> <span class="kr">raise</span> <span class="n">Change</span>
  <span class="p">|</span> <span class="nf">change</span> <span class="p">(</span><span class="n">coin::coins</span><span class="p">)</span> <span class="n">amt</span> <span class="p">=</span> 
           <span class="kr">if</span> <span class="n">coin</span> <span class="n">&gt;</span> <span class="n">amt</span> <span class="kr">then</span> <span class="n">change</span> <span class="n">coins</span> <span class="n">amt</span>  
           <span class="cm">(*ignore this coin, look at other available coins*)</span>
           <span class="kr">else</span> <span class="n">cont</span> <span class="n">change</span> <span class="p">(</span><span class="n">coin::coins</span><span class="p">)</span> <span class="p">(</span><span class="n">amt</span> <span class="n">-</span> <span class="n">coin</span><span class="p">)</span> 
           <span class="cm">(*could raise Change exception in following recursive steps *)</span>
           <span class="kr">handle</span> <span class="n">Change</span> <span class="p">=&gt;</span> <span class="n">change</span> <span class="n">coins</span> <span class="n">amt</span>
</pre></div>


<p>There are some situations where we cannot give change at all, but <code>change</code> does not handle these situations. Below, we handle this situation - <code>change</code> might not be able to do anything but raise <code>Change</code>, so this must be caught.</p>
<div class="codehilite"><pre><span class="kr">fun</span> <span class="nf">change_top</span> <span class="n">coins</span> <span class="n">amt</span> <span class="p">=</span>
    <span class="kr">let</span> <span class="kr">val</span> <span class="nv">r</span> <span class="p">=</span> <span class="n">change</span> <span class="n">coins</span> <span class="n">amt</span>
    <span class="kr">in</span> <span class="n">print</span> <span class="p">(</span><span class="s2">&quot;Change:&quot;</span> <span class="n">^</span> <span class="n">ListToString</span> <span class="n">r</span><span class="p">)</span>
    <span class="kr">end</span>
    <span class="kr">handle</span> <span class="n">Change</span> <span class="p">=&gt;</span> <span class="n">print</span> <span class="s2">&quot;Sorry, can&#39;t give change.&quot;</span>
</pre></div>


<div class="codehilite"><pre><span class="n">change</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="mi">8</span>
<span class="n">=&gt;*</span> <span class="kr">if</span> <span class="mi">5</span><span class="n">&gt;</span><span class="mi">8</span> <span class="kr">then</span> <span class="p">...</span> <span class="kr">else</span> <span class="p">(</span><span class="mi">5</span><span class="n">::change</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="mi">3</span> <span class="kr">handle</span> <span class="n">Change</span> <span class="n">change</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="mi">8</span><span class="p">)</span>

<span class="n">change</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="mi">3</span> 
<span class="n">=&gt;*</span> <span class="mi">2</span><span class="n">::</span><span class="p">(</span><span class="n">change</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="mi">1</span> <span class="kr">handle</span> <span class="n">Change</span> <span class="n">change</span> <span class="p">[]</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">change</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="mi">1</span> <span class="p">=&gt;</span> <span class="n">change</span> <span class="p">[]</span> <span class="mi">1</span> <span class="p">=&gt;</span> <span class="kr">raise</span> <span class="n">Change</span>
<span class="cm">(* goes to handle Change change [] 1 *)</span>
<span class="cm">(* then goes to handle Change change [2] 8, which succeeds *)</span>
</pre></div>


<h2 class="header"><i>10</i>8 February<a class="headerlink" href="#8-february" name="8-february">&para;</a></h2>
<h3 class="header"><i>10.1</i>References (State)<a class="headerlink" href="#references-state" name="references-state">&para;</a></h3>
<p>Recall the binding/scope rules from the beginning of the class:</p>
<div class="codehilite"><pre><span class="kr">let</span> 
    <span class="kr">val</span> <span class="nv">pi</span> <span class="p">=</span> <span class="mf">3.14</span>
    <span class="kr">val</span> <span class="nv">area</span> <span class="p">=</span> <span class="kr">fn</span> <span class="n">r</span> <span class="p">=&gt;</span> <span class="n">pi</span> <span class="n">*</span> <span class="n">r</span> <span class="n">*</span> <span class="n">r</span>
    <span class="kr">val</span> <span class="nv">a2</span> <span class="p">=</span> <span class="n">area</span> <span class="mf">2.0</span> <span class="cm">(*a2 = 12.56 *)</span>
    <span class="kr">val</span> <span class="nv">pi</span> <span class="p">=</span> <span class="mf">6.0</span>
<span class="kr">in</span>
    <span class="n">area</span> <span class="p">(</span><span class="mf">2.0</span><span class="p">)</span> <span class="cm">(* a2 = 12.56 *)</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>


<p>So far, we have only seen bindings like the one above. For bindings, remember we have a variable name bound to some value.<br />
Today we will look at references, which are a form of mutable storage. References allow us to to imperative programming.</p>
<p>Commands:</p>
<ul>
<li>Initialize a cell in memory:<br />
<code>val r : int ref = ref 0</code> where <code>r</code> is the name of the cell and <code>0</code> is the content of the cell<br />
<code>val s : int ref = ref 0</code> where <code>s</code> and <code>r</code> do not point to the same cell in memory</li>
<li>Read what is stored in a cell:<br />
<code>val x = !r</code> will read from location <code>r</code> the value <code>0</code><br />
<code>r : int ref</code> and <code>!r : int</code></li>
<li>Write some value into a cell (i.e update the content):<br />
<code>r := 5 + 3</code> where <code>r : int ref</code> and <code>5+3 : int</code><br />
  Previous content of cell <code>r</code> is erased when we store <code>8</code>.<br />
  Evaluating <code>r:=3</code> returns <code>unit</code> and as an effect updates the content of the cell with <code>3</code>.</li>
</ul>
<p><code>val x = !s + !r</code> binds <code>x</code> to <code>3</code>.</p>
<p><code>val t = r</code> essentially makes two names for the same cell in memory. Calling <code>val y = !t</code> binds <code>y</code> to the value of <code>r</code>. This is called <em>aliasing</em>.</p>
<p>We can rewrite our beginning function:</p>
<div class="codehilite"><pre><span class="kr">let</span>
   <span class="kr">val</span> <span class="nv">pi</span> <span class="p">=</span> <span class="n">ref</span> <span class="mf">3.14</span>
   <span class="kr">val</span> <span class="nv">area</span> <span class="p">=</span> <span class="kr">fn</span> <span class="n">r</span> <span class="p">=&gt;</span> <span class="n">!pi</span> <span class="n">*</span> <span class="n">r</span> <span class="n">*</span> <span class="n">r</span>
   <span class="kr">val</span> <span class="nv">a2</span> <span class="p">=</span> <span class="n">area</span> <span class="mf">2.0</span> <span class="cm">(* a2 = 12.56 *)</span>
   <span class="kr">val</span> <span class="p">_</span> <span class="p">=</span> <span class="p">(</span><span class="n">pi</span> <span class="n">:=</span> <span class="mf">6.0</span><span class="p">)</span>
<span class="kr">in</span>
   <span class="n">area</span> <span class="p">(</span><span class="mf">2.0</span><span class="p">)</span> <span class="cm">(* 24.00*)</span>
<span class="kr">end</span>
</pre></div>


<p>Now we can program mutable data structures like Linked Lists:</p>
<div class="codehilite"><pre><span class="kr">datatype</span> <span class="nd">&#39;a</span> <span class="kt">rlist</span> <span class="p">=</span> <span class="nc">Empty</span> <span class="p">|</span> <span class="nc">RCons</span> <span class="kr">of</span> <span class="nd">&#39;a</span> <span class="n">*</span> <span class="p">(</span><span class="nd">&#39;a</span> <span class="n">rlist</span><span class="p">)</span> <span class="n">ref</span><span class="p">;</span>
<span class="kr">val</span> <span class="nv">l1</span> <span class="p">=</span> <span class="n">ref</span> <span class="p">(</span><span class="n">RCons</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">ref</span> <span class="n">Empty</span><span class="p">));</span>
</pre></div>


<p>For <code>l1</code>, we now have a value <code>4</code> with a reference to some place in memory with an <code>Empty</code> list.</p>
<div class="codehilite"><pre><span class="kr">val</span> <span class="nv">l2</span> <span class="p">=</span> <span class="n">ref</span> <span class="p">(</span><span class="n">RCons</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">l1</span><span class="p">));</span>
</pre></div>


<p>For <code>l2</code> we have a value <code>5</code> with a reference to <code>l1</code> defined above.</p>
<div class="codehilite"><pre><span class="n">l1</span> <span class="n">:=</span> <span class="n">!l2</span><span class="p">;</span>
</pre></div>


<p>The above will remove the value of <code>l1</code>, change it to <code>5</code> (<code>l2</code>'s value) and create a reference back to this element. Here, we've created a circular list.</p>
<div class="codehilite"><pre><span class="kr">type</span> <span class="nd">&#39;a</span> <span class="kt">reflist</span> <span class="p">=</span> <span class="p">(</span><span class="nd">&#39;a</span> <span class="n">rlist</span><span class="p">)</span> <span class="n">ref</span><span class="p">;</span>
<span class="cm">(* rapp: &#39;a reflist * &#39;a reflist -&gt; unit *)</span>
<span class="cm">(* returns unit as all we&#39;re doing is updating space in memory *)</span>
<span class="kr">fun</span> <span class="nf">rapp</span> <span class="p">(</span><span class="n">r1</span> <span class="kr">as</span> <span class="n">ref</span> <span class="n">Empty</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span> <span class="p">=</span> <span class="n">r1</span> <span class="n">:=</span> <span class="n">!r2</span>
  <span class="p">|</span> <span class="nf">rapp</span> <span class="p">(</span><span class="n">ref</span> <span class="p">(</span><span class="n">RCons</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">)),</span> <span class="n">r2</span><span class="p">)</span> <span class="p">=</span> <span class="n">rapp</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span>
</pre></div>


<p>Now we can check this with some examples:</p>
<div class="codehilite"><pre><span class="kr">val</span> <span class="nv">rlist1</span> <span class="p">=</span> <span class="n">ref</span> <span class="p">(</span><span class="n">RCons</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">ref</span> <span class="n">Empty</span><span class="p">))</span>
<span class="kr">val</span> <span class="nv">rlist2</span> <span class="p">=</span> <span class="n">ref</span> <span class="p">(</span><span class="n">RCons</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">ref</span> <span class="n">Empty</span><span class="p">))</span>
<span class="n">rapp</span> <span class="p">(</span><span class="n">rlist1</span><span class="p">,</span> <span class="n">rlist2</span><span class="p">)</span>
</pre></div>


<h2 class="header"><i>11</i>10 February<a class="headerlink" href="#10-february" name="10-february">&para;</a></h2>
<h3 class="header"><i>11.1</i>References and the environment diagram<a class="headerlink" href="#references-and-the-environment-diagram" name="references-and-the-environment-diagram">&para;</a></h3>
<h4 class="header"><i>11.1.1</i>References for modelling closures and objects<a class="headerlink" href="#references-for-modelling-closures-and-objects" name="references-for-modelling-closures-and-objects">&para;</a></h4>
<div class="codehilite"><pre><span class="kr">local</span>
   <span class="kr">val</span> <span class="nv">counter</span> <span class="p">=</span> <span class="n">ref</span> <span class="mi">0</span>
<span class="kr">in</span>
   <span class="cm">(* tick: unit -&gt; unit *)</span>
   <span class="kr">fun</span> <span class="nf">tick</span> <span class="p">()</span> <span class="p">=</span> <span class="n">counter</span> <span class="n">:=</span> <span class="n">!counter</span> <span class="n">+</span> <span class="mi">1</span>
   <span class="cm">(* reset: unit -&gt; unit *)</span>
   <span class="kr">fun</span> <span class="nf">reset</span> <span class="p">()</span> <span class="p">=</span> <span class="n">counter</span> <span class="n">:=</span> <span class="mi">0</span>
   <span class="cm">(* read: unit -&gt; int *)</span>
   <span class="kr">fun</span> <span class="nf">read</span> <span class="p">()</span> <span class="p">=</span> <span class="n">!counter</span>
<span class="kr">end</span>
</pre></div>


<p>We can use this to create a counter program:</p>
<div class="codehilite"><pre><span class="kr">fun</span> <span class="nf">newCounter</span> <span class="p">()</span> <span class="p">=</span>
    <span class="kr">let</span>
       <span class="kr">val</span> <span class="nv">counter</span> <span class="p">=</span> <span class="n">ref</span> <span class="mi">0</span>
       <span class="kr">fun</span> <span class="nf">tick</span> <span class="p">()</span> <span class="p">=</span> <span class="n">counter</span> <span class="n">:=</span> <span class="n">!counter</span> <span class="n">+</span> <span class="mi">1</span>
       <span class="kr">fun</span> <span class="nf">reset</span> <span class="p">()</span> <span class="p">=</span> <span class="n">counter</span> <span class="n">:=</span> <span class="mi">0</span>
       <span class="kr">fun</span> <span class="nf">read</span> <span class="p">()</span> <span class="p">=</span> <span class="n">!counter</span>
    <span class="kr">in</span>
       <span class="p">{</span><span class="n">tick</span> <span class="p">=</span> <span class="n">tick</span><span class="p">;</span> <span class="n">reset</span> <span class="p">=</span> <span class="n">reset</span><span class="p">;</span> <span class="n">read</span> <span class="p">=</span> <span class="n">read</span><span class="p">}</span>
    <span class="kr">end</span>

<span class="kr">val</span> <span class="nv">c1</span> <span class="p">=</span> <span class="n">newCounter</span> <span class="p">();</span> 
<span class="kr">val</span> <span class="nv">c2</span> <span class="p">=</span> <span class="n">newCounter</span> <span class="p">();</span>

<span class="nl">#tick</span> <span class="n">c1</span> <span class="p">();</span> <span class="cm">(* increments c1&#39;s counter *)</span>
<span class="nl">#tick</span> <span class="n">c2</span> <span class="p">();</span>
<span class="nl">#tick</span> <span class="n">c1</span> <span class="p">();</span>
<span class="nl">#read</span> <span class="n">c1</span> <span class="p">();</span> <span class="cm">(* returns 2 *)</span>
<span class="nl">#read</span> <span class="n">c2</span> <span class="p">();</span> <span class="cm">(* returns 1 *)</span>
</pre></div>


<p>In essence, we've created an object - every time we create a new counter, we create an instance of the object. We can now program in the object-oriented paradigm using ML (although the syntax isn't quite as built for OOP).</p>
<h4 class="header"><i>11.1.2</i>The Environment Diagram<a class="headerlink" href="#the-environment-diagram" name="the-environment-diagram">&para;</a></h4>
<p><code>let val x = 5+3 in x+7 end:</code> will replace <code>x</code> by <code>8</code> then compute <code>8+7</code>.</p>
<p>So far, evaluation is driven by substitution. We substitute the value of <code>x</code> into the body. Unfortunately, the substitution model fails when we have references because substitutions cannot capture global effects.</p>
<p>We have three different kinds of bindings we'd like to track using the environment diagram. A binding is an association between a variable and a value.</p>
<ul>
<li><code>val x = 3+2</code> creates a "box" with the variable name <code>x</code> and its value <code>5</code>.</li>
<li><code>val x = ref (8+2)</code> creates a box with the variable name and a location pointing to another box with the value <code>10</code>.</li>
<li><code>val f = fn x =&gt; x + 3</code> creates a box with the function name and a location pointing to a box with the input and the function body, where this box points back to the original box.<br />
<code>val f = let val y = 8+2 in fn y =&gt; y + x end</code> adds another box (an extra step) with the local body.</li>
</ul>
<h2 class="header"><i>12</i>13 February<a class="headerlink" href="#13-february" name="13-february">&para;</a></h2>
<h3 class="header"><i>12.1</i>Lazy Evaluation<a class="headerlink" href="#lazy-evaluation" name="lazy-evaluation">&para;</a></h3>
<p>So far, we've had an <em>eager evaluation</em> strategy. For example, <code>let x = e1 in e2 end</code> will evaluate <code>e1</code> to some value <code>v1</code> and bind <code>x</code> to the value <code>v1</code>, then evaluate <code>e2</code>. This is also known as a <em>call-by-value</em> strategy. Why should we evaluate <code>e1</code> if we never use it at all?</p>
<p>This is especially relevant with "harder" computations.</p>
<div class="codehilite"><pre><span class="kr">let</span> 
  <span class="kr">val</span> <span class="nv">y</span> <span class="p">=</span> <span class="n">horribleComp</span><span class="p">(</span><span class="mi">322</span><span class="p">)</span>
<span class="kr">in</span> 
  <span class="mi">3</span><span class="n">*</span><span class="mi">2</span> 
<span class="kr">end</span>
</pre></div>


<p>With the call-by-value strategy, we always compute <code>horribleComp(322)</code>, even if we never use it.</p>
<p>We also have the <em>call-by-name</em> strategy. In the original example, it will bind <code>x</code> to the expression <code>e1</code>, then evaluate <code>e2</code>. However, if we use <code>x</code> multiple times in <code>e2</code>, we are evaluating <code>e1</code> multiple times.</p>
<p>There's a "best of both worlds" strategy we can also use -- the <em>call-by-need</em> strategy. In our original example, the call-by-need strategy will bind <code>x</code> to the expression <code>e1</code>, then evaluate <code>e2</code>, but memorize the result of evaluating <code>e1</code>.</p>
<p>Lazy evaluation is not only useful for saving computation time, but it also useful for evaluating infinite data structures. A stream of numbers online or interactive input/output from users would not be possible to deal with without infinite data structures.</p>
<p>Remember that continuations delay computation within functions. We can wrap functions around things we wish to delay.</p>
<div class="codehilite"><pre><span class="kr">datatype</span> <span class="nd">&#39;a</span> <span class="kt">susp</span> <span class="p">=</span> <span class="nc">Susp</span> <span class="kr">of</span> <span class="p">(</span><span class="n">unit</span> <span class="p">-&gt;</span> <span class="nd">&#39;a</span><span class="p">)</span>

<span class="cm">(* takes in a continuation and wraps it in a suspension to delay computation *)</span>
<span class="cm">(* delay: (unit -&gt; &#39;a) -&gt; &#39;a susp *)</span>
<span class="kr">fun</span> <span class="nf">delay</span> <span class="n">c</span> <span class="p">=</span> <span class="n">Susp</span> <span class="n">c</span>
<span class="cm">(* forces computation of inner function *)</span>
<span class="kr">fun</span> <span class="nf">force</span> <span class="p">(</span><span class="n">Susp</span> <span class="n">c</span><span class="p">)</span> <span class="p">=</span> <span class="n">c</span> <span class="p">()</span>
</pre></div>


<p>Now we can use lazy evaluation with the <code>horribleComp</code> example:</p>
<div class="codehilite"><pre><span class="cm">(* original *)</span>
<span class="kr">let</span> <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="n">horribleComp</span><span class="p">(</span><span class="mi">522</span><span class="p">)</span>
<span class="kr">in</span> <span class="n">x+x</span> <span class="kr">end</span>

<span class="cm">(* call-by-name model *)</span>
<span class="kr">let</span> <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="n">Susp</span><span class="p">(</span><span class="kr">fun</span> <span class="p">()</span> <span class="nf">=&gt;</span> <span class="n">horribleComp</span><span class="p">(</span><span class="mi">522</span><span class="p">))</span>
<span class="kr">in</span> <span class="n">force</span> <span class="n">x</span> <span class="n">+</span> <span class="n">force</span> <span class="n">x</span> <span class="kr">end</span>

<span class="cm">(* call-by-need *)</span>
<span class="cm">(* Not sure if this is correct *)</span>
<span class="kr">val</span> <span class="nv">memo</span> <span class="p">=</span> <span class="n">ref</span> <span class="n">None</span>
<span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="n">Susp</span> <span class="p">(</span><span class="kr">fun</span> <span class="p">()</span> <span class="nf">=&gt;</span> 
  <span class="kr">case</span> <span class="n">memo</span> <span class="kr">of</span> 
    <span class="n">None</span> <span class="p">=&gt;</span>
        <span class="kr">let</span> <span class="kr">val</span> <span class="nv">y</span> <span class="p">=</span> <span class="n">horribleComp</span><span class="p">(</span><span class="mi">522</span><span class="p">)</span> <span class="kr">in</span> <span class="n">memo</span> <span class="n">:=</span> <span class="n">y+y</span> <span class="kr">end</span>
    <span class="n">|</span> <span class="n">Some</span> <span class="n">y</span> <span class="p">=&gt;</span> <span class="n">y</span>

<span class="cm">(* infinite stream of &#39;a *)</span>
<span class="kr">datatype</span> <span class="nd">&#39;a</span> <span class="kt">stream&#39;</span> <span class="p">=</span> <span class="nc">Cons</span> <span class="kr">of</span> <span class="nd">&#39;a</span> <span class="n">*</span> <span class="nd">&#39;a</span> <span class="n">stream</span>
<span class="kr">withtype</span> <span class="nd">&#39;a</span> <span class="kt">stream</span> <span class="p">=</span> <span class="p">(</span><span class="nd">&#39;a</span> <span class="n">stream&#39;</span><span class="p">)</span> <span class="n">susp</span>
<span class="cm">(* stream&#39; shows the first element, hides the rest, while stream hides all *)</span>

<span class="cm">(* create an infinite stream of, say, 1&#39;s *)</span>
<span class="kr">fun</span> <span class="nf">ones</span> <span class="p">()</span> <span class="p">=</span> <span class="n">Susp</span> <span class="p">(</span><span class="kr">fun</span> <span class="p">()</span> <span class="nf">=&gt;</span> <span class="n">Cons</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ones</span> <span class="p">()))</span>
<span class="kr">val</span> <span class="nv">o</span> <span class="p">=</span> <span class="n">ones</span><span class="p">()</span> <span class="cm">(* returns a Susp of a function *)</span>

<span class="cm">(* take: int -&gt; &#39;a stream -&gt; &#39;a list</span>
<span class="cm">   take&#39;: int -&gt; &#39;a stream&#39; -&gt; &#39;a list</span>
<span class="cm">*)</span>
<span class="kr">fun</span> <span class="nf">take</span> <span class="mi">0</span> <span class="n">s</span> <span class="p">=</span> <span class="p">[]</span>
  <span class="p">|</span> <span class="nf">take</span> <span class="n">n</span> <span class="n">s</span> <span class="p">=</span> <span class="n">take&#39;</span> <span class="n">n</span> <span class="p">(</span><span class="n">force</span> <span class="n">s</span><span class="p">)</span>
<span class="kr">and</span> <span class="nf">take&#39;</span> <span class="mi">0</span> <span class="n">s&#39;</span> <span class="p">=</span> <span class="p">[]</span>
  <span class="p">|</span> <span class="nf">take&#39;</span> <span class="n">n</span> <span class="p">(</span><span class="n">Cons</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">s</span><span class="p">))</span> <span class="p">=</span> <span class="n">x::</span><span class="p">(</span><span class="n">take</span> <span class="p">(</span><span class="n">n-</span><span class="mi">1</span><span class="p">)</span> <span class="n">s</span><span class="p">)</span>

<span class="kr">val</span> <span class="nv">l</span> <span class="p">=</span> <span class="n">take</span> <span class="mi">5</span> <span class="p">(</span><span class="n">ones</span> <span class="p">())</span> <span class="cm">(*returns [1,1,1,1,1]*)</span>

<span class="cm">(* numsFrom: int -&gt; int stream *)</span>
<span class="kr">fun</span> <span class="nf">numsFrom</span> <span class="n">n</span> <span class="p">=</span> <span class="n">Susp</span><span class="p">(</span><span class="kr">fn</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Cons</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">numsFrom</span> <span class="p">(</span><span class="n">n-</span><span class="mi">1</span><span class="p">))</span>

<span class="n">take</span> <span class="mi">5</span> <span class="p">(</span><span class="n">numsFrom</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">(* returns [0,1,2,3,4] *)</span>
</pre></div>


<p>We can compute a stream of Fibonacci numbers:</p>
<div class="codehilite"><pre><span class="kr">val</span> <span class="nv">fibStream</span> <span class="p">=</span>
    <span class="kr">let</span>
        <span class="kr">fun</span> <span class="nf">fib</span> <span class="n">a</span> <span class="n">b</span> <span class="p">=</span> <span class="n">Cons</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Susp</span><span class="p">(</span><span class="kr">fn</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">fib</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">a+b</span><span class="p">)))</span>
    <span class="kr">in</span>
        <span class="n">Susp</span><span class="p">(</span><span class="kr">fn</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">fib</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span>
    <span class="kr">end</span>

<span class="n">take</span> <span class="mi">4</span> <span class="n">fibStream</span><span class="p">;</span> <span class="cm">(* [0,1,1,2] *)</span>
</pre></div>


<h2 class="header"><i>13</i>15 February<a class="headerlink" href="#15-february" name="15-february">&para;</a></h2>
<h3 class="header"><i>13.1</i>Lazy programming continued<a class="headerlink" href="#lazy-programming-continued" name="lazy-programming-continued">&para;</a></h3>
<p>Recall from last class:</p>
<div class="codehilite"><pre><span class="kr">datatype</span> <span class="nd">&#39;a</span> <span class="kt">susp</span> <span class="p">=</span> <span class="nc">Susp</span> <span class="kr">of</span> <span class="p">(</span><span class="n">unit</span> <span class="p">-&gt;</span> <span class="nd">&#39;a</span><span class="p">)</span>
<span class="kr">datatype</span> <span class="nd">&#39;a</span> <span class="kt">stream&#39;</span> <span class="p">=</span> <span class="nc">Cons</span> <span class="kr">of</span> <span class="nd">&#39;a</span> <span class="n">*</span> <span class="nd">&#39;a</span> <span class="n">stream</span>
<span class="kr">withtype</span> <span class="nd">&#39;a</span> <span class="kt">stream</span> <span class="p">=</span> <span class="p">(</span><span class="nd">&#39;a</span> <span class="n">stream&#39;</span><span class="p">)</span> <span class="n">susp</span>
</pre></div>


<p>Last class we saw how to create infinite streams of real numbers, natural numbers, etc..</p>
<div class="codehilite"><pre><span class="cm">(* shd: &#39;a stream -&gt; &#39;a *)</span>
<span class="kr">fun</span> <span class="nf">shd</span> <span class="p">(</span><span class="n">Susp</span> <span class="n">s</span><span class="p">)</span> <span class="p">=</span> <span class="n">shd&#39;</span> <span class="p">(</span><span class="n">s</span> <span class="p">())</span> 
<span class="cm">(* shd&#39;: &#39;a stream&#39; -&gt; &#39;a *)</span>
<span class="kr">and</span> <span class="nf">shd&#39;</span> <span class="p">(</span><span class="n">Cons</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">s</span><span class="p">))</span> <span class="p">=</span> <span class="n">h</span>
</pre></div>


<p>The first line is equivalent to <code>fun shd s = shd' (force s)</code>.</p>
<div class="codehilite"><pre><span class="cm">(* ltail: &#39;a stream -&gt; &#39;a stream *)</span>
<span class="kr">fun</span> <span class="nf">ltail</span> <span class="n">s</span> <span class="p">=</span> <span class="n">ltail&#39;</span> 
<span class="cm">(* ltail&#39;: &#39;a stream&#39; -&gt; &#39;a stream *)</span>
<span class="kr">and</span> <span class="nf">ltail&#39;</span> <span class="p">(</span><span class="n">Cons</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">s</span><span class="p">))</span> <span class="p">=</span> <span class="n">s</span>

<span class="cm">(* smap: (&#39;a -&gt; &#39;b) -&gt; &#39;a stream -&gt; &#39;b stream *)</span>
<span class="cm">(* mapStr: &#39;a stream -&gt; &#39;b stream *)</span>
<span class="cm">(* mapStr&#39;: &#39;a stream&#39; -&gt; &#39;b stream *)</span>
<span class="kr">fun</span> <span class="nf">smap</span> <span class="n">f</span> <span class="n">s</span> <span class="p">=</span>
<span class="kr">let</span> <span class="kr">fun</span> <span class="nf">mapStr</span> <span class="n">s</span> <span class="p">=</span> <span class="n">mapStr&#39;</span> <span class="p">(</span><span class="n">force</span> <span class="n">s</span><span class="p">)</span>
    <span class="kr">and</span> <span class="nf">mapStr&#39;</span> <span class="p">(</span><span class="n">Cons</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">))</span> <span class="p">=</span> <span class="n">Cons</span><span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">,</span> <span class="n">Susp</span> <span class="p">(</span><span class="kr">fn</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">mapStr</span> <span class="n">xs</span><span class="p">))</span>
<span class="kr">in</span> <span class="n">mapStr</span> <span class="n">s</span>
<span class="kr">end</span>
</pre></div>


<div class="codehilite"><pre><span class="cm">(* addStreams: int stream * int stream -&gt; int stream *)</span>
<span class="kr">fun</span> <span class="nf">addStreams</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="p">=</span> <span class="n">addStreams&#39;</span> <span class="p">(</span><span class="n">force</span> <span class="n">s1</span><span class="p">,</span> <span class="n">force</span> <span class="n">s2</span><span class="p">)</span>
<span class="cm">(* addStreams&#39;: int stream&#39; * int stream&#39; -&gt; int stream *)</span>
<span class="kr">and</span> <span class="nf">addStreams&#39;</span> <span class="p">(</span><span class="n">Cons</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">xs</span><span class="p">),</span> <span class="n">Cons</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">ys</span><span class="p">))</span> <span class="p">=</span> <span class="n">Susp</span><span class="p">(</span><span class="kr">fn</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Cons</span><span class="p">(</span><span class="n">x+y</span><span class="p">,</span> <span class="n">addStreams</span> <span class="p">(</span><span class="n">xs</span><span class="p">,</span><span class="n">ys</span><span class="p">)))</span>

<span class="cm">(* zipStreams: &#39;a stream * &#39;a stream -&gt; &#39;a stream *)</span>
<span class="kr">fun</span> <span class="nf">zipStreams</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="p">=</span> <span class="n">zipStream&#39;</span> <span class="p">(</span><span class="n">force</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
<span class="cm">(* zipStreams&#39;: &#39;a stream&#39; * [&#39;a stream] -&gt; &#39;a stream *)</span>
<span class="kr">and</span> <span class="nf">zipStreams&#39;</span> <span class="p">(</span><span class="n">Cons</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">xs</span><span class="p">),</span> <span class="n">s2</span><span class="p">)</span> <span class="p">=</span>
    <span class="n">Susp</span><span class="p">(</span><span class="kr">fn</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Cons</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">zipStreams</span> <span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">xs</span><span class="p">)))</span>
</pre></div>


<p>We don't need to force both streams for the <code>zipStreams</code> function to save work.</p>
<div class="codehilite"><pre><span class="cm">(* filter: (&#39;a-&gt;bool)*&#39;a stream -&gt; &#39;a stream *)</span>
<span class="kr">fun</span> <span class="nf">filter</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="p">=</span> <span class="n">filter&#39;</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">force</span> <span class="n">s</span><span class="p">)</span>
<span class="cm">(* filter&#39;: (&#39;a -&gt; bool) * &#39;a stream&#39; -&gt; &#39;a stream *)</span>
<span class="kr">and</span> <span class="nf">filter&#39;</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="n">Cons</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">xs</span><span class="p">)))</span> <span class="p">=</span> 
    <span class="kr">if</span> <span class="n">p</span> <span class="n">x</span> <span class="kr">then</span>
       <span class="n">Susp</span><span class="p">(</span><span class="kr">fn</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Cons</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">filter</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">xs</span><span class="p">)))</span>
    <span class="kr">else</span>
       <span class="n">filter</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
</pre></div>


<h2 class="header"><i>14</i>27 February<a class="headerlink" href="#27-february" name="27-february">&para;</a></h2>
<h3 class="header"><i>14.1</i>Midterm Review<a class="headerlink" href="#midterm-review" name="midterm-review">&para;</a></h3>
<h4 class="header"><i>14.1.1</i>Example 1: Proofs<a class="headerlink" href="#example-1-proofs" name="example-1-proofs">&para;</a></h4>
<div class="codehilite"><pre><span class="kr">fun</span> <span class="nf">sum</span> <span class="p">[]</span> <span class="p">=</span> <span class="mi">0</span>
  <span class="p">|</span> <span class="nf">sum</span> <span class="p">(</span><span class="n">h::t</span><span class="p">)</span> <span class="p">=</span> <span class="n">h</span> <span class="n">+</span> <span class="n">sum</span> <span class="n">t</span>

<span class="kr">fun</span> <span class="nf">sum_tl</span> <span class="p">[]</span> <span class="n">acc</span> <span class="p">=</span> <span class="n">acc</span>
  <span class="p">|</span> <span class="nf">sum_tl</span> <span class="p">(</span><span class="n">h::t</span><span class="p">)</span> <span class="n">acc</span> <span class="p">=</span> <span class="n">sum_tl</span> <span class="n">t</span> <span class="p">(</span><span class="n">h</span> <span class="n">+</span> <span class="n">acc</span><span class="p">)</span>
</pre></div>


<p>For the above code, we wish to prove that <code>sum l = sum_tl l 0</code>. We can do this using structural induction on <code>l</code>. </p>
<p>The base case is trivial. We'll start with the step case where <code>l = h::t</code>. Our induction hypothesis states that <code>sum t = sum_tl t 0</code>. We'll need to show that <code>sum (h::t) = sum_tl (h::t) 0</code>.</p>
<div class="codehilite"><pre><span class="n">sum</span> <span class="p">(</span><span class="n">h::t</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="n">h</span> <span class="n">+</span> <span class="n">sum</span> <span class="n">t</span>

<span class="n">sum_tl</span> <span class="p">(</span><span class="n">h::t</span><span class="p">)</span> <span class="mi">0</span>
<span class="p">=&gt;</span> <span class="n">sum_tl</span> <span class="n">t</span> <span class="p">(</span><span class="n">h+</span><span class="mi">0</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="n">sum_tl</span> <span class="n">t</span> <span class="n">h</span>
</pre></div>


<p>This attempt will not work, since we want to use the IH. We'll need to generalize the theorem:</p>
<p><strong>Lemma:</strong> For all lists <code>t</code> and for all accumulators <code>acc</code>, <code>sum t + acc = sum_tl t acc</code> is true. We'll also need to prove this using structural induction on <code>t</code>.</p>
<p>Base case: where <code>t = []</code>:</p>
<div class="codehilite"><pre><span class="n">sum</span> <span class="p">[]</span> <span class="n">+</span> <span class="n">acc</span>
<span class="p">=&gt;</span> <span class="mi">0</span> <span class="n">+</span> <span class="n">acc</span>
<span class="p">=&gt;</span> <span class="n">acc</span>

<span class="n">sum_tl</span> <span class="p">[]</span> <span class="n">acc</span>
<span class="p">=&gt;</span> <span class="n">acc</span>
</pre></div>


<p>Both sides are equal, so our base case checks out.</p>
<p>Step case: where <code>t = h::t'</code>:</p>
<div class="codehilite"><pre><span class="n">IH</span><span class="p">:</span> <span class="n">for</span> <span class="n">all</span> <span class="n">acc&#39;</span><span class="p">,</span> <span class="n">sum</span> <span class="n">t&#39;</span> <span class="n">+</span> <span class="n">acc&#39;</span> <span class="p">=</span> <span class="n">sum_tl</span> <span class="n">t&#39;</span> <span class="n">acc&#39;</span>

<span class="n">sum</span> <span class="p">(</span><span class="n">h::t&#39;</span><span class="p">)</span> <span class="n">+</span> <span class="n">acc&#39;</span>
<span class="p">=&gt;</span> <span class="p">(</span><span class="n">h</span> <span class="n">+</span> <span class="n">sum</span> <span class="n">t&#39;</span><span class="p">)</span> <span class="n">+</span> <span class="n">acc&#39;</span> <span class="p">[</span><span class="n">by</span> <span class="n">program</span><span class="p">]</span>
<span class="n">=&gt;*</span> <span class="n">sum</span> <span class="n">t&#39;</span> <span class="n">+</span> <span class="p">(</span><span class="n">h</span> <span class="n">+</span> <span class="n">acc&#39;</span><span class="p">)</span> <span class="p">[</span><span class="n">by</span> <span class="n">associativity</span> <span class="kr">and</span> <span class="nv">commutativity</span><span class="p">]</span>

<span class="n">sum_tl</span> <span class="p">(</span><span class="n">h::t&#39;</span><span class="p">)</span> <span class="n">acc&#39;</span>
<span class="p">=&gt;</span> <span class="n">sum_tl</span> <span class="n">t&#39;</span> <span class="p">(</span><span class="n">h</span> <span class="n">+</span> <span class="n">acc&#39;</span><span class="p">)</span> <span class="p">[</span><span class="n">by</span> <span class="n">program</span><span class="p">]</span>
</pre></div>


<p>By the induction hypothesis using <code>(h + acc)</code> for <code>acc'</code>, we know these are equal.</p>
<p>Now that we've proved the lemma, we need to prove the main theorem.</p>
<p>By the lemma, using <code>l</code> for <code>t</code> and <code>0</code> for <code>acc</code>:</p>
<div class="codehilite"><pre><span class="n">sum</span> <span class="n">l</span> <span class="n">+</span> <span class="mi">0</span>
<span class="p">=&gt;</span> <span class="n">sum</span> <span class="n">l</span>
</pre></div>


<h4 class="header"><i>14.1.2</i>Example 2: Rewriting library functions<a class="headerlink" href="#example-2-rewriting-library-functions" name="example-2-rewriting-library-functions">&para;</a></h4>
<p>We have a library function:</p>
<div class="codehilite"><pre><span class="n">tabulate</span> <span class="n">f</span> <span class="n">n</span> <span class="n">returns</span>  <span class="p">[</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="p">...,</span> <span class="kr">fn</span><span class="p">]</span>
</pre></div>


<p>We want to write this in a tail-recursive manner.</p>
<div class="codehilite"><pre><span class="kr">fun</span> <span class="nf">tabulate</span> <span class="n">f</span> <span class="mi">0</span> <span class="n">acc</span> <span class="p">=</span> <span class="p">(</span><span class="n">f</span> <span class="mi">0</span><span class="p">)</span><span class="n">::acc</span>
  <span class="p">|</span> <span class="nf">tabulate</span> <span class="n">f</span> <span class="n">n</span> <span class="n">acc</span> <span class="p">=</span> <span class="n">tabulate</span> <span class="n">f</span> <span class="p">(</span><span class="n">n-</span><span class="mi">1</span><span class="p">)</span> <span class="p">((</span><span class="n">f</span> <span class="n">n</span><span class="p">)</span><span class="n">::acc</span><span class="p">)</span>
</pre></div>


<p>Another example:</p>
<div class="codehilite"><pre><span class="n">foldr</span> <span class="n">f</span> <span class="n">b</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">xn</span><span class="p">]</span> <span class="n">returns</span> <span class="n">f</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">f</span> <span class="p">(</span><span class="n">xn</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
</pre></div>


<p>Now, we want to write a list append function using <code>foldr</code>.</p>
<div class="codehilite"><pre><span class="kr">fun</span> <span class="nf">append</span> <span class="n">l1</span> <span class="n">f2</span> <span class="p">=</span> 
    <span class="n">foldr</span> <span class="p">(</span><span class="kr">fn</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">x::r</span><span class="p">)</span> <span class="n">l2</span> <span class="n">l1</span>
</pre></div>


<p>We can also write a <code>filter</code> function:</p>
<div class="codehilite"><pre><span class="kr">fun</span> <span class="nf">filter</span> <span class="n">p</span> <span class="n">l</span> <span class="p">=</span>
   <span class="n">foldr</span> <span class="p">(</span><span class="kr">fn</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="kr">if</span> <span class="p">(</span><span class="n">p</span> <span class="n">x</span><span class="p">)</span> <span class="kr">then</span> <span class="n">x::r</span> <span class="kr">else</span> <span class="n">r</span><span class="p">)</span> <span class="p">[]</span> <span class="n">l</span>
</pre></div>


<div class="codehilite"><pre><span class="cm">(* all: (&#39;a -&gt; bool) -&gt; &#39;a list -&gt; bool *)</span>
<span class="kr">fun</span> <span class="nf">all</span> <span class="n">p</span> <span class="p">[]</span> <span class="p">=</span> <span class="n">true</span>
  <span class="p">|</span> <span class="nf">all</span> <span class="n">p</span> <span class="p">(</span><span class="n">h::t</span><span class="p">)</span> <span class="p">=</span> 
        <span class="n">p</span> <span class="n">h</span> <span class="kr">andalso</span> <span class="n">all</span> <span class="n">p</span> <span class="n">t</span>
</pre></div>


<h2 class="header"><i>15</i>02 March - Post-Midterm<a class="headerlink" href="#02-march-post-midterm" name="02-march-post-midterm">&para;</a></h2>
<h3 class="header"><i>15.1</i>Midterm review<a class="headerlink" href="#midterm-review_1" name="midterm-review_1">&para;</a></h3>
<h4 class="header"><i>15.1.1</i>Question 1<a class="headerlink" href="#question-1" name="question-1">&para;</a></h4>
<p>Dot product of two vectors <span>$a \dot b = \sum_{i=1}^n a_1 \times b_1$</span></p>
<p>Use <code>pair_foldr</code> <span>$ = f(x_n,y_n,f(x_{n-1},y_{n-1}, \ldots, f(x_1, y_1, init)) \ldots )$</span>.</p>
<div class="codehilite"><pre><span class="cm">(* pair_foldr (&#39;a * &#39;b *&#39;c -&gt; &#39;c) -&gt; &#39;c -&gt; (&#39;a list * &#39;b list) -&gt; &#39;c *)</span>
<span class="kr">fun</span> <span class="nf">prod_vect</span> <span class="n">v</span> <span class="n">w</span> <span class="p">=</span>
    <span class="n">pair_foldr</span> <span class="p">(</span><span class="kr">fn</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">a*b</span> <span class="n">+</span> <span class="n">c</span><span class="p">)</span>
          <span class="mi">0</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>


<h4 class="header"><i>15.1.2</i>Question 2<a class="headerlink" href="#question-2" name="question-2">&para;</a></h4>
<p>Matrices question:</p>
<div class="codehilite"><pre><span class="p">[</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">-</span><span class="mi">5</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="p">]</span>
</pre></div>


<div class="codehilite"><pre><span class="kr">fun</span> <span class="nf">emptyMatrix</span> <span class="n">B</span> <span class="p">=</span>
    <span class="n">all</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">l</span> <span class="p">=&gt;</span> <span class="n">l</span> <span class="p">=</span> <span class="p">[])</span> <span class="n">B</span>

<span class="cm">(* multiply a vector times a matrix *)</span>
<span class="kr">fun</span> <span class="nf">sm</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="p">=</span> 
<span class="kr">if</span> <span class="n">emptyMatrix</span> <span class="n">B</span> <span class="kr">then</span> <span class="p">[]</span>
<span class="kr">else</span> <span class="kr">let</span>
   <span class="kr">val</span> <span class="nv">c</span> <span class="p">=</span> <span class="n">map</span> <span class="p">(</span><span class="kr">fn</span> <span class="p">(</span><span class="n">x::xs</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="n">B</span>
   <span class="kr">val</span> <span class="nv">B&#39;</span> <span class="p">=</span> <span class="n">map</span> <span class="p">(</span><span class="kr">fn</span> <span class="p">(</span><span class="n">x::xs</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">xs</span><span class="p">)</span> <span class="n">B</span>
<span class="kr">in</span>
   <span class="n">prod_vect</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="n">::sm</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">B&#39;</span><span class="p">)</span>
<span class="kr">end</span>
</pre></div>


<h4 class="header"><i>15.1.3</i>Question 3<a class="headerlink" href="#question-3" name="question-3">&para;</a></h4>
<p>Proofs question: similar structure to past proofs</p>
<h4 class="header"><i>15.1.4</i>Question 4<a class="headerlink" href="#question-4" name="question-4">&para;</a></h4>
<p>References question:</p>
<div class="codehilite"><pre><span class="cm">(* mon_ref: &#39;a -&gt; (unit -&gt; int) * (unit -&gt; &#39;a) * (&#39;a -&gt; unit) *)</span>
<span class="kr">fun</span> <span class="nf">mon_ref</span> <span class="n">a</span> <span class="p">=</span> 
<span class="kr">let</span>
   <span class="kr">val</span> <span class="nv">r</span> <span class="p">=</span> <span class="n">ref</span> <span class="n">a</span>
   <span class="kr">val</span> <span class="nv">c</span> <span class="p">=</span> <span class="n">ref</span> <span class="mi">0</span>
<span class="kr">in</span>
   <span class="p">(</span>
     <span class="p">(</span><span class="kr">fn</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">!c</span><span class="p">),</span>
     <span class="p">(</span><span class="kr">fn</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">c</span> <span class="n">:=</span> <span class="n">!c</span> <span class="n">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">!r</span><span class="p">)),</span>
     <span class="p">(</span><span class="kr">fn</span> <span class="n">a</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">c</span> <span class="n">:=</span> <span class="n">!c</span> <span class="n">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">r</span> <span class="n">:=</span> <span class="n">a</span><span class="p">)</span>
   <span class="p">)</span>
<span class="kr">end</span>
</pre></div>


<h2 class="header"><i>16</i>05 March -- Post-Midterm Material<a class="headerlink" href="#05-march-post-midterm-material" name="05-march-post-midterm-material">&para;</a></h2>
<h3 class="header"><i>16.1</i>Introduction to Language Design<a class="headerlink" href="#introduction-to-language-design" name="introduction-to-language-design">&para;</a></h3>
<p>"A good designer must rely on experience, on precise, logical thinking, and on pedantic exactness. No magic will do." -- N. Worth</p>
<p><strong>Goal:</strong> a precise foundation for answering questions such as:</p>
<ul>
<li>How will a program execute?</li>
<li>What is the meaning of a program?</li>
<li>What are legal expressions?<br />
  e.g. <code>fun foo x x = x+2</code> and <code>foo 3 5</code> returns 7 instead of 5</li>
<li>What concept of a variable do we have?</li>
<li>Where is a variable bound?</li>
<li>When is an expression well-typed?</li>
<li>Does every expression have a unique type?</li>
<li>What exactly is an expression?<br />
  Code --&gt; Parser (syntax checker) --&gt; Type Checker (static semantics) --&gt; Interpreter (operational semantics)</li>
</ul>
<p>In this class, we'll go through the different stages of running an ML program -- parsing, type checking, and interpreting. To ensure a language will produce "correct" programs, we have to ensure that each of these stages produce correct results. </p>
<h3 class="header"><i>16.2</i>Nano ML<a class="headerlink" href="#nano-ml" name="nano-ml">&para;</a></h3>
<p>We'll start with a small subset of ML. </p>
<p><strong>Definition:</strong> the set of expressions is inductively defined as follows:</p>
<ul>
<li>A number is an expression.</li>
<li>The boolean <code>true</code> and <code>false</code> are expressions.</li>
<li>If <code>e1</code> and <code>e2</code> are expressions, then <code>e1 op e2</code> is an expression, where <code>op</code> <span>$\in \{$</span> <code>+,-,*,=,&lt;</code> <span>$\}$</span>.</li>
<li>If <code>e0</code>, <code>e1</code> and <code>e2</code> are expressions, then <code>if e0 then e1 else e2</code> is an expression.</li>
</ul>
<p>A more compact way of defining expressions is the BNF grammar (Backus-Naur-Form):</p>
<div class="codehilite"><pre><span class="n">Operator</span> <span class="kr">op</span> <span class="n">:=</span> <span class="n">+</span> <span class="n">|</span> <span class="n">-</span> <span class="n">|</span> <span class="n">*</span> <span class="n">|</span> <span class="p">=</span> <span class="n">|</span> <span class="n">&lt;</span> <span class="n">|</span> <span class="kr">orelse</span>
<span class="n">Expression</span> <span class="n">e</span> <span class="n">:=</span> <span class="n">n</span> <span class="n">|</span> <span class="n">true</span> <span class="n">|</span> <span class="n">false</span> <span class="n">|</span> <span class="n">e1</span> <span class="kr">op</span> <span class="n">e2</span> <span class="n">|</span> <span class="kr">if</span> <span class="n">e0</span> <span class="kr">then</span> <span class="n">e1</span> <span class="kr">else</span> <span class="n">e2</span>
<span class="n">Value</span> <span class="n">v</span> <span class="n">:=</span> <span class="n">n</span> <span class="n">|</span> <span class="n">true</span> <span class="n">|</span> <span class="n">false</span>
</pre></div>


<p>Examples of syntactically illegal expressions:</p>
<ul>
<li><code>true false</code></li>
<li><code>+3</code></li>
<li><code>5-</code></li>
</ul>
<p>This does not type check, however -- for example, <code>true + 3</code> is syntactically legal but ill-typed.</p>
<p>"An expression <code>e</code> evaluates to a value <code>v</code>" is equivalent to a <em>judgement</em> "<code>e</code> <span>$\Downarrow$</span> <code>v</code>"</p>
<p>An expression <code>if e0 then e1 else e2</code> evaluates to some value <code>v</code> if:</p>
<ul>
<li><code>e0</code> evaluates to <code>true</code> and</li>
<li><code>e1</code> evaluates to <code>v</code>.</li>
</ul>
<p>This is equivalent to:</p>
<p><span>$$\frac{premise_1 \ldots premise_2}{conclusion}$$</span></p>
<p>For example:<br />
<span>$$\frac{e_0 \Downarrow true \quad e_1 \Downarrow v}{if \,e_0\, then\, e_1\, else \,e_2 \,\Downarrow v}$$</span></p>
<h2 class="header"><i>17</i>07 March<a class="headerlink" href="#07-march" name="07-march">&para;</a></h2>
<h3 class="header"><i>17.1</i>Language Design and Nano ML continued<a class="headerlink" href="#language-design-and-nano-ml-continued" name="language-design-and-nano-ml-continued">&para;</a></h3>
<p>Today we want to add variables and <code>let</code> expressions to our BNF grammar.</p>
<div class="codehilite"><pre><span class="n">Expression</span> <span class="n">e</span> <span class="n">:=</span> <span class="n">n</span> <span class="n">|</span> <span class="n">true</span> <span class="n">|false</span> <span class="n">|</span>
                <span class="p">...</span> <span class="n">|</span> <span class="n">x</span> <span class="n">|</span> <span class="kr">let</span> <span class="n">x</span> <span class="p">=</span> <span class="n">e</span> <span class="kr">in</span> <span class="n">e&#39;</span> <span class="kr">end</span>
</pre></div>


<p><code>x</code> here represents a class of variables <code>x,y,z,...</code>. For example:</p>
<div class="codehilite"><pre><span class="kr">let</span> 
   <span class="n">z</span> <span class="p">=</span> <span class="kr">if</span> <span class="n">true</span> <span class="kr">then</span> <span class="mi">2</span>
       <span class="kr">else</span> <span class="mi">43</span>
<span class="kr">in</span> 
   <span class="n">z</span> <span class="n">+</span> <span class="mi">123</span>
<span class="kr">end</span>
</pre></div>


<p>The following examples are not well-formed:</p>
<div class="codehilite"><pre><span class="kr">let</span> <span class="n">z</span> <span class="p">=</span> <span class="mi">302</span>
<span class="kr">in</span> <span class="n">-z</span> <span class="kr">end</span>
<span class="kr">let</span> <span class="n">x</span> <span class="p">=</span> <span class="mi">3</span> <span class="kr">in</span> <span class="n">x</span>
<span class="kr">let</span> <span class="n">x</span> <span class="p">=</span><span class="mi">3</span> <span class="n">x+</span><span class="mi">2</span> <span class="kr">end</span>
</pre></div>


<p>When is a variable bound? When is a variable free?</p>
<p><strong>Free variables:</strong> variables that are not bound. <code>FV(e)</code> is the set of free variable names. </p>
<ul>
<li><code>FV(n) = {}</code> where <code>n</code> is a number.</li>
<li><code>FV(x) = {x}</code></li>
<li><code>FV(e1 op e2) = FV(e1) ∪ FV(e2)</code></li>
<li><code>FV(let x = e1 in e2 end) = FV(e1) ∪ F(e2) \ {x}</code><br />
<code>let x=5 in let y=x+2 in y+x end end</code><br />
<code>let x=x+2 in x+3 end</code></li>
</ul>
<p>Bound variable names don't matter -- <code>let y=x+2 in y+3 end</code>.</p>
<h3 class="header"><i>17.2</i>Substitution:<a class="headerlink" href="#substitution" name="substitution">&para;</a></h3>
<p><span>$$\frac{e \Downarrow v_0 \quad [v_0/x] e^{\prime} \Downarrow v}{let \, x = e \, in \, e^{\prime} \, end \Downarrow v}$$</span></p>
<p>To evaluate <code>let x=e in e' end</code>:</p>
<ul>
<li>Evaluate <code>e</code> to <code>v0</code>.</li>
<li>Substitute <code>v0</code> for <code>x</code> in <code>e'</code>.</li>
<li>Evaluate <code>[v0/x]e'</code> to <code>v</code>.</li>
</ul>
<p><strong>Substitution:</strong> <code>[e/x]e' = e''</code> -- in <code>e'</code>, replace every free occurrence of <code>x</code> with <code>e</code>.</p>
<p>Examples:</p>
<ul>
<li><code>[e/x] n = n</code></li>
<li><code>[e/x] x = e</code></li>
<li><code>[e/x] y = y</code></li>
<li><code>[e/x] (e1 op e2) = [e/x] e1 op [e/x] e2</code></li>
<li><code>[e/x] (let y=e1 in e2 end) =</code><br />
<code>let y = [e/x] e1 in [e/x] e2 end</code><br />
  if <code>y</code> <span>$\notin$</span> <code>FV(e)</code></li>
</ul>
<p>A problem: free variables in <code>e</code> may be bound <code>y</code> (captured) if we don't guarantee that the free variables of <code>e</code> and the bound variable <code>y</code> don't clash or overlap. </p>
<p>Renaming is a special case of substitution -- <code>[y1/y] e = e'</code></p>
<p>Our substitution has to be capture-avoiding.</p>
<p>We can also add functions to our BNF grammar:</p>
<div class="codehilite"><pre><span class="n">Expression</span> <span class="n">e</span> <span class="n">:=</span> <span class="p">...</span> <span class="n">|</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">e</span>
</pre></div>


<p><strong>Evaluating functions:</strong> <code>(fn x =&gt; e)</code></p>
<p>Functions are themselves values -- we can extend our values definition:</p>
<div class="codehilite"><pre><span class="n">Values</span> <span class="n">v</span> <span class="n">:=</span> <span class="n">n</span> <span class="n">|</span> <span class="n">true</span> <span class="n">|</span> <span class="n">false</span> <span class="n">|</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">e</span>
</pre></div>


<p><span>$$\frac{}{fn \, x =&gt; \, e \Downarrow fn \, x =&gt; \,e^{\prime}}$$</span></p>
<p><span>$$\frac{e_1 \Downarrow fn \, x =&gt; e \quad e_2 \Downarrow v_2 \quad [v_2/x] e \Downarrow v}{e_1e_2 \Downarrow v}$$</span></p>
<h2 class="header"><i>18</i>09 March<a class="headerlink" href="#09-march" name="09-march">&para;</a></h2>
<ul>
<li>Evaluating expressions (recursion)</li>
<li>Turning theory into code</li>
<li>Modules</li>
</ul>
<h3 class="header"><i>18.1</i>Evaluation<a class="headerlink" href="#evaluation" name="evaluation">&para;</a></h3>
<p>In SML, you might write:</p>
<div class="codehilite"><pre><span class="kr">fun</span> <span class="nf">f</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">=</span> <span class="kr">if</span> <span class="n">x</span><span class="p">=</span><span class="mi">0</span> <span class="kr">then</span> <span class="mi">0</span>
            <span class="kr">else</span> <span class="n">x</span> <span class="n">+</span> <span class="n">f</span> <span class="p">(</span><span class="n">x-</span><span class="mi">1</span><span class="p">)</span>

<span class="cm">(* equivalent to in Nano ML *)</span>
<span class="kr">rec</span> <span class="n">f</span> <span class="p">=&gt;</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="kr">if</span> <span class="n">x</span><span class="p">=</span><span class="mi">0</span> <span class="kr">then</span> <span class="mi">0</span>
                 <span class="kr">else</span> <span class="n">x</span> <span class="n">+</span> <span class="n">f</span> <span class="p">(</span><span class="n">x-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">f</span> <span class="mi">3</span>
<span class="p">=&gt;</span> <span class="kr">if</span> <span class="mi">3</span><span class="p">=</span><span class="mi">0</span> <span class="kr">then</span> <span class="mi">0</span>
   <span class="kr">else</span> <span class="mi">3</span> <span class="n">+</span> <span class="n">f</span> <span class="p">(</span><span class="mi">3</span><span class="n">-</span><span class="mi">1</span><span class="p">)</span>
<span class="cm">(* instead *)</span>
<span class="p">(</span> <span class="kr">rec</span> <span class="n">f</span> <span class="p">=&gt;</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="kr">if</span> <span class="n">x</span><span class="p">=</span><span class="mi">0</span> <span class="kr">then</span> <span class="mi">0</span>
         <span class="kr">else</span> <span class="n">x</span> <span class="n">+</span> <span class="n">f</span> <span class="p">(</span><span class="n">x-</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="mi">3</span>

<span class="p">(</span><span class="kr">rec</span> <span class="n">f</span> <span class="p">=&gt;</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="kr">if</span> <span class="n">x</span><span class="p">=</span><span class="mi">0</span> <span class="kr">then</span> <span class="mi">0</span>
     <span class="kr">else</span> <span class="n">x</span> <span class="n">+</span> <span class="p">(</span><span class="kr">rec</span> <span class="n">f</span> <span class="p">=&gt;</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">...</span><span class="err">.))</span> <span class="mi">3</span>
<span class="p">=&gt;</span> <span class="kr">if</span> <span class="mi">3</span><span class="p">=</span><span class="mi">0</span> <span class="kr">then</span> <span class="mi">0</span>
   <span class="kr">else</span> <span class="mi">3</span> <span class="n">+</span> <span class="p">(</span><span class="kr">rec</span> <span class="n">f</span> <span class="p">=&gt;</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">...)</span> <span class="p">(</span><span class="mi">3</span><span class="n">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="p">...</span>

<span class="p">[</span><span class="n">e&#39;/x</span><span class="p">]</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">y</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">)</span> <span class="p">=</span> <span class="kr">fn</span> <span class="n">y</span> <span class="p">=&gt;</span> <span class="p">[</span><span class="n">e&#39;/x</span><span class="p">]</span> <span class="n">e</span>
<span class="n">provided</span> <span class="n">y</span> <span class="n">is</span> <span class="n">not</span> <span class="kr">in</span> <span class="n">FV</span><span class="p">(</span><span class="n">e&#39;</span><span class="p">)</span>

<span class="p">[</span><span class="n">e&#39;/x</span><span class="p">]</span> <span class="p">(</span><span class="kr">rec</span> <span class="n">f</span> <span class="p">=&gt;</span> <span class="n">e</span><span class="p">)</span> <span class="p">=</span> <span class="kr">rec</span> <span class="n">f</span> <span class="p">=&gt;</span> <span class="p">[</span><span class="n">e&#39;/x</span><span class="p">]</span> <span class="n">e</span>
<span class="kr">where</span> <span class="n">f</span> <span class="n">is</span> <span class="n">not</span> <span class="kr">in</span> <span class="n">FV</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>


<h3 class="header"><i>18.2</i>Modules<a class="headerlink" href="#modules" name="modules">&para;</a></h3>
<p>ML: Core language and the Module Language</p>
<p>Modules: two parts -- signature and structure</p>
<p><strong>Signature:</strong> interface of a structure</p>
<p><strong>Structure:</strong> program consisting of declarations</p>
<p>When does a structure implement a signature?</p>
<p><code>:&gt;</code> makes the implementation of the structure opaque. </p>
<p>A structure can provide more components, but it cannot have fewer. </p>
<p>Structures may provide more general types (e.g. using <code>'a</code> instead of <code>int</code>).</p>
<p>Structures may also implement concrete datatypes (e.g. in Queues, lists, etc.), but the signature keeps the type abstract. This is important for information hiding.</p>
<p>The order of declarations does not matter.</p>
<h2 class="header"><i>19</i>12 March<a class="headerlink" href="#12-march" name="12-march">&para;</a></h2>
<h3 class="header"><i>19.1</i>Types<a class="headerlink" href="#types" name="types">&para;</a></h3>
<p>Many ill-typed expressions will get "stuck". For example:</p>
<div class="codehilite"><pre><span class="kr">if</span> <span class="mi">0</span> <span class="kr">then</span> <span class="mi">3</span> <span class="kr">else</span> <span class="mi">3</span><span class="n">+</span><span class="mi">2</span>

<span class="mi">0</span><span class="n">+</span><span class="mi">2</span> <span class="cm">(* why is this ill-typed? *)</span>

<span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x+</span><span class="mi">1</span><span class="p">)</span> <span class="n">true</span>
</pre></div>


<p>Our evaluator will accept these expressions, but typing should rule out these ill-formed expressions. These should lead to run-time errors. Typing will ensure that we never evaluate these expressions. There will be fewer run-time errors as a consequence.</p>
<p>Typing approximates what happens during run-time. Typing allows us to detect errors early and gives us precise error messages. As a consequence, programmers can spend more time developing and less time testing their programs. </p>
<p>When we type-check an expression, we prove the absence of certain program behaviours. </p>
<p><strong>Safety:</strong> If a program is well-typed, then every intermediate state during evaluation is defined and well-typed. </p>
<p><strong>Types classify expressions according to their value.</strong> If we know what values there are in a language, we know what types there are.</p>
<p>Recall <code>Values v := n | true | false</code>. So, for now:</p>
<div class="codehilite"><pre><span class="n">Types</span> <span class="n">T</span> <span class="n">:=</span> <span class="n">int</span> <span class="n">|</span> <span class="n">bool</span>
</pre></div>


<p>The shorthand <code>e : T</code> can be read as "expression <code>e</code> has type <code>T</code>".</p>
<p><strong>Axioms:</strong></p>
<ul>
<li><code>n : int</code></li>
<li><code>false : bool</code></li>
<li><code>true : bool</code></li>
</ul>
<p>For <code>if</code>-expression <code>if e then e1 else e2</code>:</p>
<ul>
<li><code>e : bool</code></li>
<li><code>e1 : T</code></li>
<li><code>e2 : T</code></li>
</ul>
<p>We need to check that <code>e1 : T</code> and <code>e2 : T</code>.</p>
<p><span>$$\frac{e_1 \,: \, int \quad e_2 \,:\,int}{e_1 + e_2 \,:\, int}$$</span></p>
<p><span>$$\frac{e_1 \,:\,T \quad e_2 \,:\,T}{e_1 = e_2 \,:\, bool}$$</span></p>
<p>We can add tuples to our expressions: <code>Expressions e := ... | (e1, e2) | fst e | snd e</code>. We can then add tuples to possible values:</p>
<div class="codehilite"><pre><span class="n">Values</span> <span class="n">v</span> <span class="n">:=</span> <span class="n">n</span> <span class="n">|</span> <span class="n">false</span> <span class="n">|</span> <span class="n">true</span> <span class="n">|</span> <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
<span class="n">Types</span> <span class="n">T</span> <span class="n">:=</span> <span class="n">int</span> <span class="n">|</span> <span class="n">bool</span> <span class="n">|</span> <span class="n">T1</span> <span class="n">x</span> <span class="n">T2</span>
</pre></div>


<p><span>$$\frac{e_1 \,:\,T_1 \quad e_2 \, : \, T_2}{(e_1,\,e_2)\, :\, T_1 \times T_2}$$</span></p>
<p>Now for let-expressions:</p>
<div class="codehilite"><pre><span class="kr">let</span> <span class="n">x</span><span class="p">=</span><span class="mi">5</span> <span class="kr">in</span> <span class="n">x+</span><span class="mi">3</span> <span class="kr">end</span> <span class="p">:</span> <span class="n">int</span>
<span class="cm">(* as 5:int and (assuming x : int) x+3 : int *)</span>
</pre></div>


<p>Note that we need to reason about the type of variables.</p>
<p><span>$\Gamma \vdash e : T$</span> reads "Given assumption <span>$\Gamma$</span>, expression <code>e</code> has type <code>T</code>". </p>
<p><span>$$\frac{\Gamma \vdash e \,:\,bool \quad \Gamma \vdash e_1 \,:\,T \quad \Gamma \vdash e_2 \,:\,T}{\Gamma \vdash if\, e\, then \, e_1 \, else \, e2\, :\, T}$$</span></p>
<p><span>$$\frac{\Gamma(x) = T}{\Gamma \vdash x\,:\,T}$$</span></p>
<p><span>$$\frac{\Gamma \vdash e_1 \,:\,T_1 \quad \Gamma_1, x \,x:\,T_1 \vdash e_2 \,:\,T}{\Gamma \vdash let \, x = e_1 \, in \, e_2 \, end\,:\,T}$$</span></p>
<div class="codehilite"><pre><span class="n">Context</span> <span class="n">Gamma</span> <span class="n">:=</span> <span class="n">|</span> <span class="n">G1</span> <span class="n">x</span> <span class="n">T</span>
</pre></div>


<p>Each assumption is unique implies that each variable has a unique type! We'll come back to let expressions with assumptions later.</p>
<p>Axioms:<br />
<span>$$\frac{}{\Gamma \vdash n \, :\, int}$$</span></p>
<p><span>$$\frac{}{\Gamma \vdash false\, :\,bool}$$</span></p>
<p><span>$$\frac{}{\Gamma \vdash true \,: \,bool}$$</span></p>
<p>We can infer types:</p>
<div class="codehilite"><pre><span class="n">G</span> <span class="n">|-</span> <span class="n">e</span> <span class="p">:</span> <span class="n">T</span>
<span class="n">+</span>    <span class="n">+</span>   <span class="n">-</span>
</pre></div>


<p>Typing rules lend themselves to be interpreted as type-inference rules. They will infer a unique type.</p>
<h2 class="header"><i>20</i>14 March<a class="headerlink" href="#14-march" name="14-march">&para;</a></h2>
<h3 class="header"><i>20.1</i>Typing rules continued<a class="headerlink" href="#typing-rules-continued" name="typing-rules-continued">&para;</a></h3>
<p>When is an expression well-typed?</p>
<div class="codehilite"><pre><span class="n">e</span> <span class="n">:=</span> <span class="n">n</span> <span class="n">|</span> <span class="n">true</span> <span class="n">|</span> <span class="n">false</span> <span class="n">|</span> <span class="n">e1</span> <span class="kr">op</span> <span class="n">e1</span>
   <span class="n">|</span> <span class="kr">if</span> <span class="n">e</span> <span class="kr">then</span> <span class="n">e1</span> <span class="kr">else</span> <span class="n">e1</span> <span class="n">|</span> <span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span>
   <span class="n">|</span> <span class="n">x</span> <span class="n">|</span> <span class="kr">let</span> <span class="n">x</span><span class="p">=</span><span class="n">e</span> <span class="kr">in</span> <span class="n">e&#39;</span> <span class="kr">end</span>
<span class="n">T</span> <span class="n">:=</span> <span class="n">int</span> <span class="n">|</span> <span class="n">bool</span> <span class="n">|</span> <span class="n">T1</span> <span class="n">x</span> <span class="n">T2</span>
</pre></div>


<p><code>e : T</code> = "expression e has type T"</p>
<p><code>G |- e : T</code> = typing assumption about variables (e.g. Given assumptions in T, expression e has type T)</p>
<p><span>$$\frac{\Gamma \vdash e \,:\,T^{\prime} \quad \Gamma \times T^{\prime} \vdash e^{\prime}\,:\,T}{\Gamma \vdash let \, x = e\, in \, e^{\prime} \, end\,:\,T}$$</span></p>
<p>Example:<br />
<span>$$\frac{\displaystyle \frac{}{\vdash 5\, :\, int} \quad \frac{\displaystyle\frac{}{x\,:\,int\vdash x\,:\,int}\quad \frac{}{x\,:\,int \vdash 3 \,:\,int}}{x\,:\,int \vdash x+3 \,:\,int}}{ \vdash let\, x=5 \,in\, x+3\, end}$$</span></p>
<p>For every expression, we can infer a type. Every expression has a unique type.</p>
<h3 class="header"><i>20.2</i>Extensions<a class="headerlink" href="#extensions" name="extensions">&para;</a></h3>
<p>Today we will look at extensions -- functions, applications, recursion, and references. </p>
<div class="codehilite"><pre><span class="n">T</span> <span class="n">:=</span> <span class="p">...</span> <span class="n">|</span> <span class="n">T1</span> <span class="p">-&gt;</span> <span class="n">T2</span>
<span class="n">V</span> <span class="n">:=</span> <span class="p">...</span> <span class="n">|</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">e</span>
</pre></div>


<div class="codehilite"><pre><span class="n">assume</span> <span class="n">x</span><span class="p">:</span><span class="n">int</span><span class="p">,</span> <span class="n">verify</span> <span class="n">that</span> <span class="kr">if</span> <span class="n">x</span><span class="p">=</span><span class="mi">0</span> <span class="kr">else</span> <span class="n">x+</span><span class="mi">2</span> <span class="n">has</span> <span class="kr">type</span> <span class="kt">int</span>
<span class="kt">------------------------------------</span>
<span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="kr">if</span> <span class="n">x</span><span class="p">=</span><span class="mi">0</span> <span class="kr">then</span> <span class="mi">4</span> <span class="kr">else</span> <span class="n">x+</span><span class="mi">2</span> <span class="p">:</span> <span class="n">int</span>
</pre></div>


<div class="codehilite"><pre><span class="cm">(* this rule cannot be interpreted as inferring a type *)</span>
<span class="n">G1xT1|-e</span><span class="p">:</span><span class="n">T2</span>
<span class="n">-----------------------</span>
<span class="n">G|-</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">e</span> <span class="p">:</span> <span class="n">T1</span> <span class="p">-&gt;</span> <span class="n">T2</span>

<span class="cm">(* solution: annotate x with its type *)</span>
<span class="kr">fn</span> <span class="n">x</span> <span class="p">:</span> <span class="n">T1</span> <span class="p">=&gt;</span> <span class="n">e</span>

<span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="kr">if</span> <span class="n">fst</span> <span class="n">x</span><span class="p">=</span><span class="mi">0</span> <span class="kr">then</span> <span class="n">snd</span> <span class="n">x</span>
                   <span class="kr">else</span> <span class="mi">5</span>
         <span class="p">:</span> <span class="n">int</span> <span class="n">x</span> <span class="n">int</span> <span class="p">-&gt;</span> <span class="n">int</span>
</pre></div>


<p>Without type annotations, <code>fn x =&gt; x</code> has infinitely many types. With type annotations, we can infer a unique type.</p>
<p>What is the most general type of an expression? <code>'a</code> "principle type"</p>
<p>Extremely important rule:</p>
<div class="codehilite"><pre><span class="n">G|-e1</span><span class="p">:</span><span class="n">T1</span><span class="p">-&gt;</span><span class="n">T2</span>  <span class="n">G|-e2</span><span class="p">:</span><span class="n">T1</span>
<span class="n">-------------------------</span>
<span class="n">G</span> <span class="n">|-</span> <span class="n">e1</span> <span class="n">e2</span> <span class="p">:</span> <span class="n">T2</span>
</pre></div>


<p>New reference type:</p>
<div class="codehilite"><pre><span class="n">T</span> <span class="n">:=</span> <span class="p">...</span> <span class="n">|</span> <span class="n">T1</span> <span class="n">ref</span> <span class="n">|</span> <span class="n">unit</span>

<span class="n">e</span> <span class="n">:=</span> <span class="p">...</span> <span class="n">|</span> <span class="n">!e</span> <span class="n">|</span> <span class="n">e</span> <span class="n">:=</span> <span class="n">e&#39;</span> <span class="n">|</span> <span class="n">ref</span> <span class="n">e</span>
</pre></div>


<div class="codehilite"><pre><span class="n">G|-e</span> <span class="p">:</span> <span class="n">T</span> <span class="n">ref</span>
<span class="n">------------</span>
<span class="n">G</span> <span class="n">|-</span> <span class="n">!e</span> <span class="p">:</span> <span class="n">T</span>

<span class="n">G|-e</span><span class="p">:</span><span class="n">T</span>
<span class="n">---------</span>
<span class="n">G</span> <span class="n">|-</span> <span class="n">ref</span> <span class="n">e</span> <span class="p">:</span> <span class="n">ref</span> <span class="n">T</span>

<span class="n">G|-e</span><span class="p">:</span><span class="n">T</span> <span class="n">ref</span>  <span class="n">G|-e&#39;</span><span class="p">:</span><span class="n">T</span>
<span class="n">-----------------</span>
<span class="n">G</span> <span class="n">|-</span> <span class="n">e</span> <span class="n">:=</span> <span class="n">e&#39;</span> <span class="p">:</span> <span class="n">unit</span>

<span class="n">G1</span> <span class="n">f</span><span class="p">:</span><span class="n">T</span> <span class="n">|-</span> <span class="n">e</span> <span class="p">:</span> <span class="n">T</span>
<span class="n">--------------------------</span>
<span class="n">G</span> <span class="n">|-</span> <span class="n">ref</span> <span class="n">f</span> <span class="p">=&gt;</span> <span class="n">e</span> <span class="p">:</span> <span class="n">T</span>

<span class="p">(</span><span class="mi">1</span><span class="p">)</span>        <span class="p">(</span><span class="mi">2</span><span class="p">)</span>       <span class="n">sum</span><span class="p">:</span> <span class="n">int</span><span class="p">-&gt;</span><span class="n">int</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="n">int</span> <span class="n">|-</span> <span class="n">sum</span><span class="p">(</span><span class="n">x-</span><span class="mi">1</span><span class="p">)</span><span class="n">+x</span> <span class="p">:</span> <span class="n">int</span>
<span class="n">-----------------------------------------------------------------</span>
<span class="n">sum</span> <span class="n">int</span><span class="p">-&gt;</span><span class="n">int</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="n">int</span> <span class="n">|-</span> <span class="kr">if</span> <span class="n">x</span><span class="p">=</span><span class="mi">0</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> <span class="n">sum</span><span class="p">(</span><span class="n">x-</span><span class="mi">1</span><span class="p">)</span> <span class="n">+</span> <span class="n">x</span> <span class="p">:</span> <span class="n">int</span>
<span class="n">----------------------------------------------------------------</span>
<span class="n">sum</span> <span class="n">int</span><span class="p">-&gt;</span><span class="n">int</span> <span class="n">|-</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="kr">if</span> <span class="n">x</span><span class="p">=</span><span class="mi">0</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> <span class="n">sum</span><span class="p">(</span><span class="n">x-</span><span class="mi">1</span><span class="p">)</span> <span class="n">+</span> <span class="n">x</span> <span class="p">:</span> <span class="n">int</span><span class="p">-&gt;</span><span class="n">int</span>
<span class="n">----------------------------------------------------------------</span>
<span class="kr">rec</span> <span class="n">sum</span> <span class="p">=&gt;</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="kr">if</span> <span class="n">x</span><span class="p">=</span><span class="mi">0</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> <span class="n">sum</span> <span class="p">(</span><span class="n">x-</span><span class="mi">1</span><span class="p">)</span> <span class="n">+</span> <span class="n">x</span> <span class="p">:</span> <span class="n">int</span> <span class="p">-&gt;</span> <span class="n">int</span>
</pre></div>


<h2 class="header"><i>21</i>16 March<a class="headerlink" href="#16-march" name="16-march">&para;</a></h2>
<h3 class="header"><i>21.1</i>Type inference and polymorphism<a class="headerlink" href="#type-inference-and-polymorphism" name="type-inference-and-polymorphism">&para;</a></h3>
<p>Can we infer a type for an expression?</p>
<p>Recall that we needed type annotations on functions. <code>fn x : int =&gt; x</code></p>
<p>Does an expression have a unique type? <code>fn x =&gt; x</code> could have the type <code>int-&gt;int</code> or <code>bool-&gt;bool</code>, etc., however this function does have one principle type <code>'a-&gt;'a</code>.</p>
<p><strong>The question:</strong> how can we infer the principle type of an expression <em>without</em> being given type annotations?</p>
<p>Example:</p>
<div class="codehilite"><pre><span class="n">double</span> <span class="p">=</span> <span class="kr">fn</span> <span class="n">f</span> <span class="p">=&gt;</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="p">:</span> <span class="p">(</span><span class="nd">&#39;a</span> <span class="p">-&gt;</span> <span class="nd">&#39;a</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nd">&#39;a</span> <span class="p">-&gt;</span> <span class="nd">&#39;a</span>
</pre></div>


<p>Intuitively, we can now use this function in multiple ways.</p>
<div class="codehilite"><pre><span class="n">double</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x+</span><span class="mi">2</span><span class="p">)</span> <span class="mi">3</span> <span class="p">:</span> <span class="n">int</span>

<span class="n">f</span>        <span class="p">(</span> <span class="n">f</span>        <span class="n">x</span> <span class="p">)</span>
<span class="n">^</span>          <span class="n">^</span>        <span class="n">^</span>
<span class="nd">&#39;a</span><span class="p">-&gt;</span><span class="nd">&#39;b</span>    <span class="nd">&#39;a</span><span class="p">-&gt;</span><span class="nd">&#39;b</span>   <span class="nd">&#39;a</span>
              <span class="nd">&#39;b</span>
</pre></div>


<p>Because of this contradiction, we cannot pass a <span>$\beta$</span> to a function which expects an <span>$\alpha$</span>.</p>
<div class="codehilite"><pre><span class="n">double</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="n">false</span> <span class="p">:</span> <span class="n">bool</span>
</pre></div>


<p><em>Crucial in this:</em> type variables</p>
<div class="codehilite"><pre><span class="n">T</span> <span class="n">:=</span> <span class="n">int</span> <span class="n">|</span> <span class="n">bool</span> <span class="n">|</span> <span class="n">T1</span> <span class="n">x</span> <span class="n">T2</span> <span class="n">|</span> <span class="n">T1</span> <span class="p">-&gt;</span> <span class="n">T2</span> <span class="n">|</span> <span class="nd">&#39;a</span>
</pre></div>


<p>How do we instantiate type variables? Substitution!</p>
<div class="codehilite"><pre><span class="p">[</span><span class="n">T/</span><span class="nd">&#39;a</span><span class="p">]</span> <span class="p">(</span><span class="n">int</span><span class="p">)</span> <span class="p">=</span> <span class="n">int</span>
<span class="p">[</span><span class="n">T/</span><span class="nd">&#39;a</span><span class="p">]</span> <span class="p">(</span><span class="nd">&#39;a</span><span class="p">)</span> <span class="p">=</span> <span class="n">T</span>
<span class="p">[</span><span class="n">T/</span><span class="nd">&#39;a</span><span class="p">]</span> <span class="p">(</span><span class="nd">&#39;b</span><span class="p">)</span> <span class="p">=</span> <span class="nd">&#39;b</span> <span class="p">(</span><span class="kr">where</span> <span class="nd">&#39;b</span> <span class="n">!=</span> <span class="nd">&#39;a</span><span class="p">)</span>
<span class="p">[</span><span class="n">T/</span><span class="nd">&#39;a</span><span class="p">]</span> <span class="p">(</span><span class="n">T1</span> <span class="p">-&gt;</span> <span class="n">T2</span><span class="p">)</span> <span class="p">=</span> <span class="p">[</span><span class="n">T/</span><span class="nd">&#39;a</span><span class="p">]</span> <span class="n">T1</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="n">T/</span><span class="nd">&#39;a</span><span class="p">]</span> <span class="n">T2</span>
</pre></div>


<p><em>Two views:</em></p>
<ul>
<li>Are <em>all</em> substitution instances of <code>e</code> well-typed?<br />
  If e has some type T and constrains some type variables <span>$\alpha_1, \ldots, \alpha_n$</span>, then e has type <code>[T1/'a1 ... Tn/'an] T</code> for every <span>$T_1, \ldots T_n$</span>?</li>
<li>Does there exist some substitution instance such that e has type T?</li>
</ul>
<p>For example: <code>fn x =&gt; x+1</code> has type <span>$\beta$</span>? Choose for <span>$\beta =$</span> <code>int-&gt;int</code>.</p>
<p><code>fn x =&gt; x</code> has type <span>$\beta$</span>? Choose for <span>$\beta=$</span><code>int-&gt;int</code> or <code>bool-&gt;bool</code> or, most generally, <code>'a-&gt;'a</code>.</p>
<p>Will <code>fn x =&gt; x+1</code> have type <code>'b-&gt;bool</code>? No. there is no instantiation for <code>'b</code>.</p>
<h4 class="header"><i>21.1.1</i>Type inference<a class="headerlink" href="#type-inference" name="type-inference">&para;</a></h4>
<p><strong>(1)</strong> use typing rules to generate constraints. &lt;-- will always succeed<br />
<strong>(2)</strong> solve constraints. &lt;-- will sometimes fail</p>
<p>What is a constraint? For example, <code>T=bool</code>.</p>
<div class="codehilite"><pre><span class="n">Constraint</span> <span class="n">C</span> <span class="n">:=</span> <span class="n">T</span><span class="p">=</span><span class="n">T&#39;</span> <span class="n">|</span> <span class="n">tt</span> <span class="n">|</span> <span class="n">C1</span> <span class="n">^</span> <span class="n">C2</span>
</pre></div>


<p>How do we collect constraints? Informally, to infer a type for <code>if e then e1 else e2</code>, we do the following:</p>
<ol>
<li>Infer a type <span>$T$</span> for <span>$e$</span> (and <span>$C$</span>).</li>
<li>Infer a type <span>$T_1$</span> for <span>$e_1$</span> (and <span>$C_1$</span>).</li>
<li>Infer a type <span>$T_2$</span> for <span>$e_2$</span> (and <span>$C_2$</span>).</li>
</ol>
<p>Constraints: <code>T = bool ^ T1 = T2</code>.</p>
<p>To infer a type for <code>fn x =&gt; e</code>:</p>
<ol>
<li>Assume <span>$x$</span> has type <span>$\alpha_1$</span>.</li>
<li>Infer a type <span>$T_24$</span> (provided the constraints <span>$C$</span> can be solved).</li>
<li>We then know that <code>fn x =&gt; e</code> has type <code>'a1 -&gt; T2</code> (provided the constraints <span>$C$</span>).<br />
\
<code>G |- e =&gt; T  C</code> means "given the assumptions <span>$\Gamma$</span> for an expression <span>$e$</span>, the type <span>$T$</span>, and the constraints <span>$C$</span>", or "the expression <span>$e$</span> has type <span>$T$</span> provided I can solve <span>$C$</span>".</li>
</ol>
<h4 class="header"><i>21.1.2</i>Solving constraints<a class="headerlink" href="#solving-constraints" name="solving-constraints">&para;</a></h4>
<div class="codehilite"><pre><span class="n">G</span> <span class="n">|-</span> <span class="n">e</span> <span class="p">=&gt;</span> <span class="n">T/C</span>   <span class="n">G</span> <span class="n">|-</span> <span class="n">e1</span> <span class="p">=&gt;</span> <span class="n">T1/C1</span>   <span class="n">G</span> <span class="n">|-</span> <span class="n">e2</span> <span class="p">=&gt;</span> <span class="n">T2/C2</span>
<span class="n">----------------------------------------------------</span>
<span class="n">G</span> <span class="n">|-</span> <span class="kr">if</span> <span class="n">e</span> <span class="kr">then</span> <span class="n">e1</span> <span class="kr">else</span> <span class="n">e2</span> <span class="p">=&gt;</span> <span class="n">T2</span> <span class="n">/</span> <span class="n">T</span><span class="p">=</span><span class="n">book</span> <span class="n">^</span> <span class="n">T1</span><span class="p">=</span><span class="n">t2</span> <span class="n">^</span> <span class="n">C</span> <span class="n">^</span> <span class="n">C1</span> <span class="n">^</span> <span class="n">C2</span>

<span class="n">G1</span> <span class="n">x</span><span class="p">:</span><span class="nd">&#39;a1</span> <span class="n">|-</span> <span class="n">e</span> <span class="p">=&gt;</span> <span class="n">T2/C</span>
<span class="n">-------------------------</span>
<span class="n">G</span> <span class="n">|-</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">e</span> <span class="p">=&gt;</span> <span class="n">a1</span> <span class="p">-&gt;</span> <span class="n">T2</span> <span class="n">/</span> <span class="n">C</span>

<span class="n">input</span><span class="p">:</span> <span class="n">left</span> <span class="kr">of</span> <span class="p">=&gt;</span>
<span class="n">output</span><span class="p">:</span> <span class="n">right</span> <span class="kr">of</span> <span class="p">=&gt;</span>
<span class="n">x</span><span class="p">:</span><span class="nd">&#39;a1</span> <span class="n">means</span> <span class="nd">&#39;a1</span> <span class="n">is</span> <span class="n">new</span>

<span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="kr">if</span> <span class="mi">3</span><span class="p">=</span><span class="mi">1</span> <span class="kr">then</span> <span class="mi">55</span> <span class="kr">else</span> <span class="n">x</span> <span class="p">:</span> <span class="nd">&#39;a1</span> <span class="p">-&gt;</span>
<span class="n">assuming</span> <span class="n">x</span><span class="p">:</span><span class="nd">&#39;a1</span>
<span class="n">constraint</span><span class="p">:</span> <span class="n">int</span> <span class="p">=</span> <span class="nd">&#39;a1</span> <span class="n">^</span> <span class="n">bool</span><span class="p">=</span><span class="n">bool</span>
</pre></div>


<p>Solving the constraints, we learn that <code>'a1 = int</code>, and therefore</p>
<div class="codehilite"><pre><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="kr">if</span> <span class="mi">3</span><span class="p">=</span><span class="mi">1</span> <span class="kr">then</span> <span class="mi">55</span> <span class="kr">else</span> <span class="n">x</span> <span class="p">:</span> <span class="n">int</span><span class="p">-&gt;</span><span class="n">int</span>
</pre></div>


<div class="codehilite"><pre><span class="n">------------------</span>
<span class="n">G</span> <span class="n">|-</span> <span class="n">n</span> <span class="p">=&gt;</span> <span class="n">int</span> <span class="n">/</span> <span class="n">tt</span>

<span class="n">----------------------</span>
<span class="n">G</span> <span class="n">|-</span> <span class="n">true</span> <span class="p">=&gt;</span> <span class="n">bool</span> <span class="n">/</span> <span class="n">tt</span>

<span class="n">G</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">=</span> <span class="n">T</span>
<span class="n">----------------</span>
<span class="n">G</span> <span class="n">|-</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">T</span> <span class="n">/</span> <span class="n">tt</span>
</pre></div>


<h2 class="header"><i>22</i>19 March<a class="headerlink" href="#19-march" name="19-march">&para;</a></h2>
<p>Some small mistakes on HW4 -- see WebCT for more details.</p>
<h3 class="header"><i>22.1</i>Type inference<a class="headerlink" href="#type-inference_1" name="type-inference_1">&para;</a></h3>
<p>Examples:</p>
<div class="codehilite"><pre><span class="kr">fn</span> <span class="n">f</span> <span class="p">=&gt;</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="n">+</span> <span class="mi">1</span>
    <span class="p">:</span> <span class="nd">&#39;a1</span> <span class="p">-&gt;</span> <span class="nd">&#39;a2</span> <span class="p">-&gt;</span> <span class="n">int</span>
<span class="n">f</span><span class="p">:</span> <span class="nd">&#39;a1</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nd">&#39;a2</span> <span class="n">|-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="n">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">int</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">:</span> <span class="n">int</span>
<span class="nd">&#39;a1</span> <span class="p">=</span> <span class="nd">&#39;a2</span> <span class="p">-&gt;</span> <span class="n">int</span>
<span class="err">.:</span> <span class="n">the</span> <span class="kr">type</span> <span class="kr">of</span> <span class="n">the</span> <span class="kr">fn</span> <span class="n">is</span> <span class="p">(</span><span class="nd">&#39;a2</span><span class="p">-&gt;</span><span class="n">int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nd">&#39;a2</span> <span class="p">-&gt;</span> <span class="n">int</span>
    <span class="kr">as</span> <span class="n">f</span> <span class="p">:</span> <span class="nd">&#39;a2</span><span class="p">-&gt;</span><span class="n">int</span>
</pre></div>


<p>A slightly more complicated example:</p>
<div class="codehilite"><pre><span class="kr">fn</span> <span class="n">f</span> <span class="p">=&gt;</span> <span class="kr">fn</span> <span class="n">g</span> <span class="p">=&gt;</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">f</span><span class="p">(</span> <span class="n">g</span> <span class="n">x</span><span class="p">)</span> <span class="n">+</span> <span class="n">g</span> <span class="n">x</span>
    <span class="p">:</span> <span class="nd">&#39;a1</span> <span class="p">-&gt;</span> <span class="nd">&#39;a2</span> <span class="p">-&gt;</span> <span class="nd">&#39;a3</span> <span class="p">-&gt;</span> <span class="n">int</span>
<span class="n">f</span><span class="p">:</span> <span class="nd">&#39;a1</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="nd">&#39;a2</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nd">&#39;a3</span> <span class="n">|-</span> <span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="n">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">:</span> <span class="n">int</span>

<span class="n">Constraints</span> <span class="n">to</span> <span class="n">solve</span><span class="p">:</span>
<span class="nd">&#39;a2</span> <span class="p">=</span> <span class="nd">&#39;a3</span> <span class="p">-&gt;</span> <span class="n">int</span> <span class="p">(</span><span class="n">from</span> <span class="n">last</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="nd">&#39;a2</span> <span class="p">=</span> <span class="nd">&#39;a3</span> <span class="p">-&gt;</span> <span class="nd">&#39;a4</span> <span class="p">(</span><span class="n">from</span> <span class="n">first</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="nd">&#39;a1</span> <span class="p">=</span> <span class="nd">&#39;a4</span> <span class="p">-&gt;</span> <span class="n">int</span>
<span class="nd">&#39;a2</span> <span class="p">=</span> <span class="nd">&#39;a3</span> <span class="p">-&gt;</span> <span class="nd">&#39;a4</span><span class="p">,</span> <span class="nd">&#39;a2</span> <span class="p">=</span> <span class="nd">&#39;a3</span> <span class="p">-&gt;</span> <span class="n">int</span> <span class="p">(</span><span class="n">intuitively</span><span class="p">)</span>
<span class="nd">&#39;a1</span> <span class="p">=</span> <span class="nd">&#39;a4</span> <span class="p">-&gt;</span> <span class="n">int</span>
<span class="err">.:</span> <span class="nd">&#39;a4</span> <span class="p">=</span> <span class="n">int</span><span class="p">,</span> <span class="nd">&#39;a1</span> <span class="p">=</span> <span class="n">int</span> <span class="p">-&gt;</span> <span class="n">int</span>
<span class="n">No</span> <span class="n">constraint</span> <span class="n">on</span> <span class="nd">&#39;a3</span>

<span class="err">.:</span> <span class="n">the</span> <span class="kr">type</span> <span class="kt">we</span> <span class="kt">infer</span> <span class="kt">is:</span>
    <span class="p">(</span><span class="n">int</span> <span class="n">-&gt;</span> <span class="n">int</span><span class="p">)</span> <span class="kt">-&gt;</span> <span class="p">(</span><span class="nd">&#39;a3</span><span class="n">-&gt;int</span><span class="p">)</span> <span class="kt">-&gt;</span> <span class="nd">&#39;a3</span> <span class="kt">-&gt;</span> <span class="kt">int</span>
         <span class="kt">f</span>               <span class="kt">g</span>         <span class="kt">x</span>
</pre></div>


<p>Third example:</p>
<div class="codehilite"><pre><span class="kr">fn</span> <span class="n">f</span> <span class="p">=&gt;</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="n">+</span> <span class="n">x</span> <span class="n">f</span>

<span class="n">f</span><span class="p">:</span> <span class="nd">&#39;a1</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nd">&#39;a2</span> <span class="n">|-</span> <span class="n">f</span> <span class="n">x</span> <span class="n">+</span> <span class="n">x</span> <span class="n">f</span>
<span class="nd">&#39;a1</span> <span class="p">=</span> <span class="nd">&#39;a2</span> <span class="p">-&gt;</span> <span class="n">int</span>
<span class="nd">&#39;a2</span> <span class="p">=</span> <span class="nd">&#39;a1</span> <span class="p">-&gt;</span> <span class="n">int</span>

<span class="nd">&#39;a1</span> <span class="p">=</span> <span class="p">(</span><span class="nd">&#39;a1</span> <span class="p">-&gt;</span> <span class="n">int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">int</span>

<span class="n">Does</span> <span class="n">there</span> <span class="n">exist</span> <span class="n">an</span> <span class="n">instantiation</span> <span class="n">for</span> <span class="nd">&#39;a1</span> <span class="n">such</span> <span class="n">that</span>
    <span class="nd">&#39;a1</span> <span class="p">=</span> <span class="p">(</span><span class="nd">&#39;a1</span> <span class="p">-&gt;</span> <span class="n">int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">int</span> <span class="n">?</span>
<span class="n">There</span> <span class="n">is</span> <span class="n">no</span> <span class="n">solution</span> <span class="n">to</span> <span class="n">make</span> <span class="n">both</span> <span class="n">sides</span> <span class="nn">equal</span><span class="p">.</span><span class="err"></span>
<span class="n">Reason</span><span class="p">:</span> <span class="n">variable</span> <span class="n">on</span> <span class="n">the</span> <span class="n">LHS</span> <span class="n">occurs</span> <span class="n">embedded</span> <span class="n">on</span> <span class="n">the</span> <span class="n">RHS</span> <span class="p">(</span><span class="n">circular</span><span class="p">)</span><span class="err">.</span>
</pre></div>


<h3 class="header"><i>22.2</i>Unification Algorithm<a class="headerlink" href="#unification-algorithm" name="unification-algorithm">&para;</a></h3>
<p>Input: set of constraints</p>
<p>Question: Does there exist an instantiation such that all constraints are true?</p>
<p><code>C := tt | C1 ^ C2 | T = T'</code></p>
<p><code>C =====&gt; C'</code> until we reach our goal where <code>C =&gt;* tt</code>.</p>
<div class="codehilite"><pre><span class="n">C</span> <span class="n">^</span> <span class="n">tt</span> <span class="p">=&gt;</span> <span class="n">C</span>
<span class="n">C</span> <span class="n">^</span> <span class="n">int</span> <span class="p">=</span> <span class="n">int</span> <span class="p">=&gt;</span> <span class="n">C</span>
<span class="n">C</span> <span class="n">^</span> <span class="n">bool</span> <span class="p">=</span> <span class="n">bool</span> <span class="p">=&gt;</span> <span class="n">C</span>
<span class="n">C</span> <span class="n">^</span> <span class="n">T1</span><span class="p">-&gt;</span><span class="n">T2</span> <span class="p">=</span> <span class="n">S1</span><span class="p">-&gt;</span><span class="n">S2</span> <span class="p">=&gt;</span> <span class="n">C</span> <span class="n">^</span> <span class="n">T1</span><span class="p">=</span><span class="n">S2</span> <span class="n">^</span> <span class="n">T2</span><span class="p">=</span><span class="n">S2</span>
<span class="n">C</span> <span class="n">^</span> <span class="nd">&#39;a</span> <span class="p">=</span> <span class="n">T</span> <span class="p">=&gt;</span> <span class="p">[</span><span class="n">T/</span><span class="nd">&#39;a</span><span class="p">]</span> <span class="n">C</span> <span class="p">(</span><span class="n">provided</span> <span class="nd">&#39;a</span> <span class="n">is</span> <span class="n">not</span> <span class="kr">in</span> <span class="n">FV</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
    <span class="p">(</span><span class="n">occurs</span> <span class="n">check</span> <span class="n">--</span> <span class="n">prevents</span> <span class="n">circular</span> <span class="n">terms</span><span class="p">)</span>
<span class="n">C</span> <span class="n">^</span> <span class="n">T</span> <span class="p">=</span> <span class="nd">&#39;a</span> <span class="p">=&gt;</span> <span class="p">[</span><span class="n">T/</span><span class="nd">&#39;a</span><span class="p">]</span> <span class="n">C</span> <span class="p">(</span><span class="n">same</span> <span class="n">provisions</span><span class="p">)</span>
</pre></div>


<div class="codehilite"><pre><span class="n">unify</span> <span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">)</span> <span class="p">=</span>
    <span class="cm">(* pattern match on T1, T2 *)</span>
    <span class="cm">(* return bool *)</span>
</pre></div>


<h3 class="header"><i>22.3</i>Examples (part 2)<a class="headerlink" href="#examples-part-2" name="examples-part-2">&para;</a></h3>
<div class="codehilite"><pre><span class="n">double</span> <span class="p">=</span> <span class="kr">fn</span> <span class="n">f</span> <span class="p">=&gt;</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">:</span> <span class="nd">&#39;a1</span> <span class="p">-&gt;</span> <span class="nd">&#39;a2</span> <span class="p">-&gt;</span> <span class="nd">&#39;a3</span>
<span class="n">f</span><span class="p">:</span><span class="nd">&#39;a1</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span><span class="nd">&#39;a2</span> <span class="n">|-</span> <span class="n">f</span> <span class="p">(</span><span class="n">fx</span><span class="p">)</span> <span class="p">:</span> <span class="nd">&#39;a3</span>
<span class="n">inter</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="n">---&gt;</span> <span class="nd">&#39;a1</span> <span class="p">=</span> <span class="nd">&#39;a2</span> <span class="p">-&gt;</span> <span class="nd">&#39;a4</span>
<span class="n">outer</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nd">&#39;a1</span> <span class="p">=</span> <span class="nd">&#39;a4</span> <span class="p">-&gt;</span> <span class="nd">&#39;a3</span>
<span class="nd">&#39;a4</span> <span class="p">-&gt;</span> <span class="nd">&#39;a3</span> <span class="p">=&gt;</span> <span class="nd">&#39;a2</span> <span class="p">-&gt;</span> <span class="nd">&#39;a1</span>
<span class="nd">&#39;a4</span> <span class="p">=</span> <span class="nd">&#39;a2</span><span class="p">,</span> <span class="nd">&#39;a3</span> <span class="p">=</span> <span class="nd">&#39;a4</span>
<span class="err">.:</span> <span class="nd">&#39;a2</span> <span class="p">=</span> <span class="nd">&#39;a3</span> <span class="p">=</span> <span class="nd">&#39;a4</span>
<span class="err">.:</span> <span class="n">we</span> <span class="n">infer</span><span class="p">:</span>
    <span class="p">(</span><span class="nd">&#39;a2</span> <span class="p">-&gt;</span> <span class="nd">&#39;a2</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nd">&#39;a2</span> <span class="p">-&gt;</span> <span class="nd">&#39;a2</span>

<span class="n">double</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x+</span><span class="mi">1</span><span class="p">)</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">double</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="n">true</span><span class="p">;</span>

<span class="kr">let</span>
    <span class="n">d</span> <span class="p">=</span> <span class="kr">fn</span> <span class="n">f</span> <span class="p">=&gt;</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="p">=</span> <span class="n">d</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x+</span><span class="mi">1</span><span class="p">)</span> <span class="mi">5</span>
    <span class="n">y</span> <span class="p">=</span> <span class="n">d</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">)</span> <span class="n">true</span>
<span class="kr">in</span>
    <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="kr">end</span>
<span class="cm">(* this will type-check in SML, but would not type check in our definition so far,</span>
<span class="cm"> * as we don&#39;t have a way to reuse a function with different types as we&#39;ve </span>
<span class="cm"> * given it a type. SML will abstract over polymorphic type variables, i.e.</span>
<span class="cm"> * it can reuse the type over multiple types by saying &quot;for all &#39;a2:(&#39;a2-&gt;&#39;a2)-&gt;&#39;a2-&gt;&#39;a&quot;</span>
<span class="cm"> *)</span>
</pre></div>


<h2 class="header"><i>23</i>21 March<a class="headerlink" href="#21-march" name="21-march">&para;</a></h2>
<h3 class="header"><i>23.1</i>Type inference continued<a class="headerlink" href="#type-inference-continued" name="type-inference-continued">&para;</a></h3>
<h4 class="header"><i>23.1.1</i>Warm-up examples<a class="headerlink" href="#warm-up-examples" name="warm-up-examples">&para;</a></h4>
<p><strong>Example 1:</strong></p>
<div class="codehilite"><pre><span class="kr">fn</span> <span class="n">f</span> <span class="p">=&gt;</span> <span class="kr">fn</span> <span class="n">g</span> <span class="p">=&gt;</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="kr">if</span> <span class="n">gx</span> <span class="kr">then</span> <span class="n">f</span><span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span> <span class="kr">else</span> <span class="n">f</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">))</span>

<span class="n">f</span> <span class="p">:</span> <span class="nd">&#39;a1</span><span class="p">,</span> <span class="n">g</span> <span class="p">:</span> <span class="nd">&#39;a2</span><span class="p">,</span> <span class="n">x</span> <span class="p">:</span> <span class="nd">&#39;a3</span> <span class="n">|-</span> <span class="kr">if</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span> <span class="kr">then</span> <span class="n">f</span><span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span> <span class="kr">else</span> <span class="n">f</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">))</span> <span class="p">:</span> <span class="nd">&#39;a4</span>

<span class="nd">&#39;a1</span> <span class="p">-&gt;</span> <span class="nd">&#39;a2</span> <span class="p">-&gt;</span> <span class="nd">&#39;a3</span> <span class="p">-&gt;</span> <span class="nd">&#39;a4</span>
</pre></div>


<p>We are looking for instantiations for <code>'a1, 'a2, 'a3, 'a4</code> such that the expression is well-typed.</p>
<div class="codehilite"><pre><span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span> <span class="n">==</span> <span class="nd">&#39;a2</span> <span class="p">=</span> <span class="nd">&#39;a3</span> <span class="p">-&gt;</span> <span class="n">bool</span>
<span class="n">f</span><span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span> <span class="n">==</span> <span class="nd">&#39;a1</span> <span class="p">=</span> <span class="n">bool</span> <span class="p">-&gt;</span> <span class="nd">&#39;a4</span>
<span class="n">f</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">))</span> <span class="n">==</span> <span class="nd">&#39;a1</span> <span class="p">=</span> <span class="nd">&#39;a4</span> <span class="p">-&gt;</span> <span class="nd">&#39;a4</span>
<span class="err">.:</span> <span class="nd">&#39;a4</span> <span class="p">=</span> <span class="n">bool</span>
</pre></div>


<p>This given function will have type <code>(bool-&gt;bool)-&gt;('a3-&gt;bool)-&gt;'a3-&gt;bool</code>.</p>
<p><strong>Example 2:</strong></p>
<div class="codehilite"><pre><span class="kr">fn</span> <span class="n">f</span> <span class="p">=&gt;</span> <span class="kr">if</span> <span class="n">f</span> <span class="n">true</span> <span class="kr">then</span> <span class="n">f</span> <span class="mi">5</span> <span class="kr">else</span> <span class="n">f</span> <span class="mi">4</span>

<span class="n">f</span><span class="p">:</span><span class="nd">&#39;a1</span> <span class="n">|-</span> <span class="kr">if</span> <span class="n">f</span> <span class="n">true</span> <span class="kr">then</span> <span class="n">f</span> <span class="mi">5</span> <span class="kr">else</span> <span class="n">f</span> <span class="mi">4</span> <span class="p">:</span> <span class="nd">&#39;a2</span>

<span class="n">f</span> <span class="n">true</span> <span class="n">==</span> <span class="nd">&#39;a1</span> <span class="p">=</span> <span class="n">bool</span> <span class="p">-&gt;</span> <span class="n">bool</span>
<span class="n">f</span> <span class="mi">5</span><span class="p">,</span> <span class="n">f</span> <span class="mi">4</span> <span class="n">==</span> <span class="nd">&#39;a1</span> <span class="p">=</span> <span class="n">int</span> <span class="p">-&gt;</span> <span class="nd">&#39;a2</span>

<span class="n">bool</span><span class="p">-&gt;</span><span class="n">bool</span> <span class="n">!=</span> <span class="n">int</span> <span class="p">-&gt;</span> <span class="nd">&#39;a2</span>
<span class="cm">(* won&#39;t type check? *)</span>

<span class="cm">(* in SML *)</span>
<span class="kr">let</span> <span class="kr">val</span> <span class="nv">f</span> <span class="p">=</span> <span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span>
<span class="kr">in</span> <span class="kr">if</span> <span class="p">(</span><span class="n">f</span> <span class="n">true</span><span class="p">)</span> <span class="kr">then</span> <span class="p">(</span><span class="n">f</span> <span class="mi">5</span><span class="p">)</span> <span class="kr">else</span> <span class="p">(</span><span class="n">f</span> <span class="mi">4</span><span class="p">)</span>
<span class="kr">end</span>
<span class="cm">(* will type int -- why? *)</span>
</pre></div>


<p>In our algorithm:</p>
<div class="codehilite"><pre><span class="n">f</span> <span class="p">:</span> <span class="nd">&#39;a</span> <span class="p">-&gt;</span> <span class="nd">&#39;a</span> <span class="n">|-</span> <span class="kr">if</span> <span class="p">(</span><span class="n">f</span> <span class="n">true</span><span class="p">)</span> <span class="kr">then</span> <span class="n">f</span> <span class="mi">5</span> <span class="kr">else</span> <span class="n">f</span> <span class="mi">4</span>
<span class="p">(</span><span class="n">f</span> <span class="n">true</span><span class="p">)</span> <span class="n">==</span> <span class="nd">&#39;a</span> <span class="p">-&gt;</span> <span class="nd">&#39;a</span> <span class="p">=</span> <span class="n">bool</span> <span class="p">-&gt;</span> <span class="n">bool</span>
<span class="n">f</span> <span class="mi">4</span> <span class="n">==</span> <span class="nd">&#39;a</span> <span class="p">-&gt;</span> <span class="nd">&#39;a</span> <span class="p">=</span> <span class="n">int</span> <span class="p">-&gt;</span> <span class="n">int</span>
<span class="n">f</span> <span class="mi">5</span> <span class="n">==</span> <span class="s2">&quot;&quot;</span>

<span class="nd">&#39;a</span> <span class="p">=</span> <span class="n">int</span>
<span class="nd">&#39;a</span> <span class="p">=</span> <span class="n">bool</span>
</pre></div>


<p>Our algorithm does not do what SML does -- it cannot truly reuse <code>f</code> in multiple ways.</p>
<p>To make this function type check in our language, we'll need different copies of <code>f</code>.</p>
<p><strong>Observation:</strong> <code>if (fn x =&gt; x) true</code> <code>then (fn x =&gt; x) 5 then</code> <code>(fn x =&gt; x) 4</code> will type check -- each "sub-function" will be assigned its own relevant type. By writing this function three times, we will type check it three times, however we will have no constraints to carry over, so our language will type check this correctly.</p>
<h4 class="header"><i>23.1.2</i>Modifying our typing rules<a class="headerlink" href="#modifying-our-typing-rules" name="modifying-our-typing-rules">&para;</a></h4>
<p>As a solution to this problem, we can modify our old rule, which is not suitable to handle polymorphic functions. Our new rule is as follows:</p>
<div class="codehilite"><pre><span class="n">G|-</span><span class="p">[</span><span class="n">e1/x</span><span class="p">]</span><span class="n">e2</span> <span class="p">:</span> <span class="n">T</span>
<span class="n">-----------------------</span>
<span class="n">G</span> <span class="n">|-</span> <span class="kr">let</span> <span class="n">x</span><span class="p">=</span><span class="n">e1</span> <span class="kr">in</span> <span class="n">e2</span> <span class="p">:</span> <span class="n">T</span>
</pre></div>


<p>Note: type checks <span>$e_1$</span> multiple times -- not very efficient, but at least this will work for polymorphism. In practical languages, this is not what happens. Instead, we'll need to make the assumption <span>$\forall \alpha -&gt; \alpha$</span>, so whenever we look up the type of <code>f</code>, we get a "fresh", unique copy of its type. </p>
<p>In ML:<br />
(generalize -- abstract over the free variables and quantify over them, so we can reuse them as often as we'd like)</p>
<div class="codehilite"><pre><span class="n">G|-</span> <span class="n">e1</span> <span class="p">:</span> <span class="n">S</span>   <span class="n">G1</span> <span class="n">x</span> <span class="n">generalize</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="n">|-</span> <span class="n">e2</span> <span class="p">:</span> <span class="n">T</span>
<span class="n">-----------------------------------------</span>
<span class="n">G</span> <span class="n">|-</span> <span class="kr">let</span> <span class="n">x</span><span class="p">=</span><span class="n">e1</span> <span class="kr">in</span> <span class="n">e2</span> <span class="p">:</span> <span class="n">T</span>
</pre></div>


<p>In example 2, <code>(forall 'a, 'a -&gt; 'a) -&gt; int</code> -- full polymorphism. In ML, we have parametric polymorphism, where all quantification over type variables is at the outside. Some languages are slowly moving towards allowing full polymorphism.</p>
<h4 class="header"><i>23.1.3</i>More examples<a class="headerlink" href="#more-examples" name="more-examples">&para;</a></h4>
<div class="codehilite"><pre><span class="kr">let</span> <span class="kr">val</span> <span class="nv">r</span> <span class="p">=</span> <span class="n">ref</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">)</span>
<span class="kr">in</span> <span class="n">r</span> <span class="n">:=</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x+</span><span class="mi">1</span><span class="p">);</span> <span class="n">!r</span> <span class="n">true</span>
<span class="kr">end</span>
</pre></div>


<p>In SML, this will not type check; however, from the rules we have, it will.</p>
<div class="codehilite"><pre><span class="n">ref</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="n">==</span> <span class="p">(</span><span class="nd">&#39;a</span> <span class="p">-&gt;</span> <span class="nd">&#39;a</span><span class="p">)</span> <span class="n">ref</span>
<span class="n">ref</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="n">:=</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x+</span><span class="mi">1</span><span class="p">);</span> <span class="p">(</span><span class="n">ref</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">))</span><span class="n">!</span> <span class="n">true</span>
<span class="nd">&#39;a</span> <span class="p">=</span> <span class="n">int</span>
<span class="kr">then</span>
<span class="nd">&#39;a</span> <span class="p">=</span> <span class="n">bool</span>

<span class="s2">&quot;happy&quot;</span> <span class="n">but</span> <span class="n">WRONG</span>
</pre></div>


<p>In general, we can reuse functions and values in a polymorphic way, but we cannot make any general polymorphic assumptions about expressions which are not values! Recall that references are not values, so we cannot make any general polymorphic assumptions about references. </p>
<p>This is called <em>value restriction</em> -- we can only reuse values in a polymorphic way. If something is not a value, we cannot make any polymorphic assumptions about it, since there can be side effects and such.</p>
<div class="codehilite"><pre><span class="kr">let</span> <span class="kr">val</span> <span class="nv">r</span> <span class="p">=</span> <span class="n">ref</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">)</span>
<span class="kr">in</span> <span class="n">r</span>
<span class="kr">end</span>

<span class="cm">(* SML *)</span>
<span class="n">Warning</span> <span class="p">:</span> <span class="kr">type</span> <span class="kt">variables</span> <span class="kt">are</span> <span class="kt">not</span> <span class="kt">generalized</span> <span class="kt">because</span> <span class="kr">of</span> <span class="n">value</span> <span class="n">restriction</span> 
    <span class="n">are</span> <span class="n">instantiated</span> <span class="kr">with</span> <span class="n">dummy</span> <span class="n">types</span><span class="p">:</span>  <span class="n">?X1-&gt;?X1</span> <span class="n">ref</span>
</pre></div>


<h2 class="header"><i>24</i>23 March<a class="headerlink" href="#23-march" name="23-march">&para;</a></h2>
<p>HW 5 out -- due 11 April, 2012</p>
<h3 class="header"><i>24.1</i>Bi-directional type checking<a class="headerlink" href="#bi-directional-type-checking" name="bi-directional-type-checking">&para;</a></h3>
<p>So far, we have type inference rules. </p>
<p><strong>Hindley-Milner</strong> (type inference) -- <em>Goal:</em> infer the most general type of an expression without declaring any types, i.e., without type annotations.</p>
<p><strong>Advantages of writing type annotations:</strong></p>
<ul>
<li>Gives better error messages (programmer communicates his or her intent)</li>
<li>High-grade (high-quality) documentation -- does not get out of sync with the code</li>
<li>I can refuse types to force programs to be used in a specific way</li>
<li>Hindley-Milner type inference does not scale to richer types such as sub-typing, full polymorphism, and dependent types. </li>
<li>Hindley-Milner type inference is complicated and difficult to implement (unification is needed).</li>
</ul>
<p>Basic idea behind bi-directional type checking -- instead of inferring a type:<br />
<span>$$\Gamma \vdash e \Rightarrow \tau$$</span><br />
<span>$\forall e$</span> where <span>$\tau$</span> is the output, we'll use two judgements (functions), "check" and "synthesize". First, check <span>$\Gamma \vdash e \Leftarrow \tau$</span> for inputs <span>$\Gamma, e, \tau$</span> (check that expression <span>$e$</span> has type <span>$\tau$</span> under the assumptions <span>$\Gamma$</span>). Then, synthesize <span>$\Gamma \vdash e \Rightarrow \tau$</span> (synthesize a type <span>$\tau$</span> for expression <span>$e$</span> under the assumptions <span>$\Gamma$</span> for <em>some</em> <span>$e$</span>). Synthesize basically means infer.</p>
<p>This algorithm is based on two observations. First, we can't use information that we don't have. Second, we should try to use information that we do have. </p>
<p>Type variables:<br />
<span>$$\frac{}{\Gamma_i x \,:\, \tau \vdash x \Rightarrow \tau}$$</span></p>
<p>Functions<br />
<span>$$ \frac{\tau_i x \,:\, \tau_1 \vdash e \Leftarrow \tau_2}{\Gamma \vdash \text{fn x =&gt; e} \Rightarrow \tau_1 \rightarrow \tau_2}$$</span></p>
<p><span>$$\frac{\Gamma \vdash e_1 \Rightarrow \tau_2 \rightarrow \tau \quad \Gamma \vdash e_2 \Leftarrow \tau_2}{\Gamma \vdash e_1 e_2}$$</span></p>
<p>Example:</p>
<div class="codehilite"><pre><span class="n">twice</span><span class="p">:</span> <span class="p">(</span><span class="n">int</span> <span class="p">-&gt;</span> <span class="n">int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">int</span> <span class="p">-&gt;</span> <span class="n">int</span><span class="p">)</span>
    <span class="n">|-</span> <span class="p">(</span><span class="n">twice</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x+</span><span class="mi">1</span><span class="p">))</span> <span class="mi">3</span>
        <span class="n">----</span>
        <span class="n">^</span> <span class="n">infer</span> <span class="kr">type</span> <span class="p">(</span><span class="n">int-&gt;int</span><span class="p">)</span><span class="kt">-&gt;int-&gt;int</span>
<span class="err">.:</span> <span class="n">int</span>
</pre></div>


<p>Conversion:<br />
<span>$$\frac{\Gamma \vdash e \Rightarrow \tau^{\prime} \quad \tau^{\prime} = \tau}{\Gamma \vdash e \Leftarrow \tau}$$</span></p>
<p>Example:<br />
<span>$$\frac{\vdash 3 \Rightarrow int \quad int = int}{\vdash 3 \Leftarrow int}$$</span></p>
<h2 class="header"><i>25</i>26 March<a class="headerlink" href="#26-march" name="26-march">&para;</a></h2>
<h3 class="header"><i>25.1</i>Subtyping<a class="headerlink" href="#subtyping" name="subtyping">&para;</a></h3>
<div class="codehilite"><pre><span class="kr">fun</span> <span class="nf">area</span> <span class="n">r</span> <span class="p">=</span> <span class="mf">3.14</span> <span class="n">*</span> <span class="n">r</span> <span class="n">*</span> <span class="n">r</span>

<span class="n">area</span> <span class="p">:</span> <span class="n">real</span> <span class="p">-&gt;</span> <span class="n">real</span>
<span class="n">area</span> <span class="mi">2</span> <span class="cm">(* type error *)</span>
</pre></div>


<p>We want to pass an int whenever a real is required (int <span>$\leq$</span> real)</p>
<p><em>Subtyping principle:</em> S <span>$&lt;$</span> T. S is a subtype of T if we can provide a value of type S whenever a value of T is required.</p>
<p><span>$$\frac{\Gamma \vdash e : S  \quad S \leq T}{\Gamma \vdash e : T}$$</span></p>
<p><span>$$\frac{T \leq R \quad  R \leq S}{T \leq S}$$</span></p>
<p><span>$$\frac{T_1 \leq S_1 \quad T_2 \leq S_2}{T_1 \times T_2 \leq S_1 \times S_2} \text{ (covariant)}$$</span></p>
<p>Records are a generalization of tuples (n-ary tuples where each element has a label).</p>
<p><span>$$\frac{\forall i \; T_i \leq s_1}{\{x_1 : T_1, \dots, x_n : T_1 \} \leq \{ x_1 : S_1, \dots, x_n : S_1 \} } \text{ (depth \; subtyping)}$$</span></p>
<p>Two things we want for records:</p>
<ul>
<li>Permutations of elements should be allowed! </li>
</ul>
<p><span>$$\frac{\{ x_1 : T_1, \dots, x_n : T_n\} \leq \{ x_{\phi(1)} : T_{\phi(1)}, \dots, x_{\phi(n)} : T_{\phi(n)} \} }{  \phi \text{is a permutation}}$$</span></p>
<p>(MISSED FROM FAR BOARD lol)</p>
<p><span>$$\frac{\{x_1 : T_1, \dots, x_k : T_k\} &lt; \{x_1 : T_1, \dots, x_n : T_n\}}{k &gt; n}$$</span></p>
<h4 class="header"><i>25.1.1</i>Function example<a class="headerlink" href="#function-example" name="function-example">&para;</a></h4>
<div class="codehilite"><pre><span class="kr">let</span>
    <span class="cm">(* areaSqr: real -&gt; real *)</span>
    <span class="kr">fun</span> <span class="nf">areaSqr</span> <span class="p">(</span><span class="n">r</span> <span class="p">:</span> <span class="n">real</span><span class="p">)</span> <span class="p">=</span> <span class="n">r*r</span>
    <span class="cm">(* areaFake: real -&gt; int *)</span>
    <span class="kr">fun</span> <span class="nf">areaFake</span> <span class="p">(</span><span class="n">r</span> <span class="p">:</span> <span class="n">real</span><span class="p">)</span> <span class="p">=</span> <span class="mi">3</span>
<span class="kr">in</span>
    <span class="n">areaSqr</span> <span class="mf">2.2</span> <span class="n">+</span> <span class="mf">3.2</span>
<span class="kr">end</span>
</pre></div>


<p><strong>Question:</strong> Can we provide <code>areaFake: real -&gt; int</code> whenever <code>areaSqr: real -&gt; real</code> is required? YES, but not in SML -- our discussion of subtyping is purely theoretical.</p>
<p>Therefore,<br />
<span>$$\frac{T_2 \leq S_2}{T \rightarrow T_2 \leq T \rightarrow S_2}$$</span></p>
<h2 class="header"><i>26</i>28 March<a class="headerlink" href="#28-march" name="28-march">&para;</a></h2>
<h3 class="header"><i>26.1</i>Subtyping continued<a class="headerlink" href="#subtyping-continued" name="subtyping-continued">&para;</a></h3>
<h4 class="header"><i>26.1.1</i>Review<a class="headerlink" href="#review" name="review">&para;</a></h4>
<p>Basic subtyping principle: <span>$S \leq T$</span> "S is a subtype of T" if we can provide a value of type S whenever a value of type T is required. </p>
<p>Products: covariant <code>int * real &lt;= real * real</code> <code>real * int &lt;= real * real</code></p>
<p>Functions: contravariant <code>int -&gt; int &lt;= int -&gt; real</code> as <code>int &lt;= real</code> and functions are co-variant in the output type.</p>
<p><code>real -&gt; int &lt;= int -&gt; int</code> as <code>int &lt;= real</code> and functions are contra-variant in the input type.</p>
<p>Invalid: <code>int -&gt; int !&lt;= real -&gt; real</code></p>
<p><span>$$\frac{S_1 \leq T_1 \quad T_2 \leq S_2}{T_1 \rightarrow T_2 \leq S_1 \rightarrow S_2}$$</span></p>
<h4 class="header"><i>26.1.2</i>References<a class="headerlink" href="#references" name="references">&para;</a></h4>
<div class="codehilite"><pre><span class="kr">let</span>
    <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="n">ref</span> <span class="mf">2.0</span>
    <span class="kr">val</span> <span class="nv">y</span> <span class="p">=</span> <span class="n">ref</span> <span class="mi">3</span>
<span class="kr">in</span>
    <span class="n">!x</span> <span class="n">+</span> <span class="mf">3.14</span>
<span class="kr">end</span>
</pre></div>


<p>This is a perfectly valid program, as <code>x : real ref</code> and <code>y : int ref</code>. Can we supply an <code>int ref</code> (e.g. <code>y</code>) whenever a <code>real ref</code> is required? YES (but, again, not in SML).</p>
<p><span>$$\frac{ S \leq T }{S ref \leq T ref}$$</span></p>
<div class="codehilite"><pre><span class="kr">let</span>
    <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="n">ref</span> <span class="mf">2.0</span>
    <span class="kr">val</span> <span class="nv">y</span> <span class="p">=</span> <span class="n">ref</span> <span class="mi">2</span>
<span class="kr">in</span>
    <span class="n">y</span> <span class="n">:=</span> <span class="mi">4</span> 
<span class="kr">end</span>
</pre></div>


<p>Should we be able to supply a <code>real ref</code> (e.g. <code>x</code>) whenever an <code>int ref</code> is required? YES. This seems almost contradictory, since we said yes to the previous question. The following rule seems incompatible to the one before:</p>
<p><span>$$\frac{T \leq S}{S ref \leq T ref}$$</span></p>
<p>Therefore, there is <em>no subtyping</em> on references (locations) -- references are <em>invariant</em>.<br />
<span>$$\frac{S \leq T \quad T \leq S}{S ref \leq T ref}$$</span><br />
Of course, if <span>$S \leq T$</span> and <span>$T \leq S$</span>, then <span>$S = T$</span>.</p>
<h4 class="header"><i>26.1.3</i>More subtyping<a class="headerlink" href="#more-subtyping" name="more-subtyping">&para;</a></h4>
<p>Recall the typing rule for subtyping:<br />
<span>$$\frac{\Gamma \vdash e : S \quad S \leq T}{\Gamma \vdash e : T}$$</span> <br />
Upcasting is always safe with type annotations -- it is safe to "forget"!<br />
<span>$$\frac{\Gamma \vdash e : S \quad S \leq T}{\Gamma \vdash (T) e : T} \text{ (Upcasting)}$$</span></p>
<p>Below, there can be no relationship between S and T. This is not really safe in general. Most often, S is a supertype of T. You must trust that this is safe in order to use it.</p>
<p><span>$$\frac{\Gamma \vdash e : S}{\Gamma \vdash (T) e : T}$$</span></p>
<p>E.g. <code>fn (x:real) =&gt; (int) x + 1</code> downcasts <code>x</code> to an <code>int</code>.</p>
<h2 class="header"><i>27</i>30 March<a class="headerlink" href="#30-march" name="30-march">&para;</a></h2>
<h3 class="header"><i>27.1</i>Dependent types<a class="headerlink" href="#dependent-types" name="dependent-types">&para;</a></h3>
<div class="codehilite"><pre><span class="kr">fun</span> <span class="nf">append</span> <span class="p">[]</span> <span class="n">l</span> <span class="p">=</span> <span class="n">l</span>
  <span class="p">|</span> <span class="nf">append</span> <span class="p">(</span><span class="n">h::t</span><span class="p">)</span> <span class="n">l</span> <span class="p">=</span> <span class="n">h::</span><span class="p">(</span><span class="n">append</span> <span class="n">t</span> <span class="n">l</span><span class="p">)</span>

<span class="cm">(* append: &#39;a list -&gt; &#39;a list -&gt; &#39;a list *)</span>
</pre></div>


<p>What else do we know?</p>
<div class="codehilite"><pre><span class="n">length</span> <span class="p">(</span><span class="n">append</span> <span class="n">l1</span> <span class="n">l2</span><span class="p">)</span> <span class="p">=</span> <span class="n">length</span> <span class="n">l1</span> <span class="n">+</span> <span class="n">length</span> <span class="n">l2</span>
</pre></div>


<p>How can types track information about the length of lists? Index a type by an object/expression which stands for an integer. </p>
<div class="codehilite"><pre><span class="n">for</span> <span class="n">all</span> <span class="n">n</span> <span class="p">:</span> <span class="n">int</span><span class="p">,</span> <span class="n">for</span> <span class="n">all</span> <span class="n">m</span> <span class="p">:</span> <span class="n">int</span><span class="p">:</span>
<span class="n">list</span> <span class="nd">&#39;a</span> <span class="n">n</span> <span class="p">-&gt;</span> <span class="n">list</span> <span class="nd">&#39;a</span> <span class="n">m</span> <span class="p">-&gt;</span> <span class="n">list</span> <span class="nd">&#39;a</span> <span class="p">(</span><span class="n">plus</span> <span class="n">n</span> <span class="n">m</span><span class="p">)</span>
</pre></div>


<p>Agda (a dependently typed functional language), DML (Dependent ML), Omega, Epigram, Coq, ...</p>
<p>Staring with simple types in Agda:</p>
<div class="codehilite"><pre><span class="n">data</span> <span class="n">Nat</span> <span class="p">:</span> <span class="n">Set</span> <span class="kr">where</span>
     <span class="n">zero</span> <span class="p">:</span> <span class="n">Nat</span>
     <span class="n">succ</span> <span class="p">:</span> <span class="n">Nat</span> <span class="p">-&gt;</span> <span class="n">Nat</span>
<span class="n">data</span> <span class="n">Bool</span> <span class="p">:</span> <span class="n">Set</span> <span class="kr">where</span>
     <span class="n">true</span> <span class="p">:</span> <span class="n">Bool</span>
     <span class="n">false</span> <span class="p">:</span> <span class="n">Bool</span>

<span class="n">data</span> <span class="n">List</span> <span class="p">(</span><span class="n">A</span> <span class="p">:</span> <span class="n">Set</span><span class="p">)</span> <span class="p">:</span> <span class="n">Set</span> <span class="kr">where</span>
     <span class="p">[]</span> <span class="p">:</span> <span class="n">List</span> <span class="n">A</span>
     <span class="p">_</span><span class="n">::</span><span class="p">_</span> <span class="p">:</span> <span class="n">A</span> <span class="p">-&gt;</span> <span class="n">List</span> <span class="n">A</span> <span class="p">-&gt;</span> <span class="n">List</span> <span class="n">A</span>
</pre></div>


<p>In Agda, we have to explicitly declare the type of a program:</p>
<div class="codehilite"><pre><span class="n">plus</span> <span class="p">:</span> <span class="n">Nat</span> <span class="p">-&gt;</span> <span class="n">Nat</span> <span class="p">-&gt;</span> <span class="n">Nat</span>
<span class="n">plus</span> <span class="n">zero</span> <span class="n">m</span> <span class="p">=</span> <span class="n">m</span>
<span class="n">plus</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="n">m</span> <span class="p">=</span> <span class="n">succ</span> <span class="p">(</span><span class="n">plus</span> <span class="n">n</span> <span class="n">m</span><span class="p">)</span>

<span class="n">rev_tl</span> <span class="p">:</span> <span class="p">{</span><span class="n">A</span> <span class="p">:</span> <span class="n">Set</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="n">List</span> <span class="n">A</span> <span class="p">-&gt;</span> <span class="n">List</span> <span class="n">A</span> <span class="p">-&gt;</span> <span class="n">List</span> <span class="n">A</span>
<span class="n">rev_tl</span> <span class="p">[]</span> <span class="n">acc</span> <span class="p">=</span> <span class="n">acc</span>
<span class="n">rev_tl</span> <span class="p">(</span><span class="n">h::t</span><span class="p">)</span> <span class="n">acc</span> <span class="p">=</span> <span class="n">rev_tl</span> <span class="n">t</span> <span class="p">(</span><span class="n">h::acc</span><span class="p">)</span>
</pre></div>


<p>The <code>{A : Set}</code> clause is read as "for all <code>A</code>".</p>
<p>Dependent types:<br />
Index a boolean list with its length</p>
<div class="codehilite"><pre><span class="n">data</span> <span class="n">BoolList</span> <span class="p">:</span> <span class="n">Nat</span> <span class="p">-&gt;</span> <span class="n">Set</span> <span class="kr">where</span>
     <span class="n">nil</span> <span class="p">:</span> <span class="n">BoolList</span> <span class="n">zero</span>
     <span class="n">cons</span> <span class="p">:</span> <span class="p">{</span><span class="n">n</span> <span class="p">:</span> <span class="n">Nat</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="n">Bool</span> <span class="p">-&gt;</span> <span class="n">BoolList</span> <span class="n">n</span> <span class="p">-&gt;</span> <span class="n">BoolList</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span>

<span class="n">append</span> <span class="p">:</span> <span class="p">{</span><span class="n">n</span> <span class="p">:</span> <span class="n">Nat</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="p">{</span><span class="n">m</span> <span class="p">:</span> <span class="n">Nat</span><span class="p">}</span> <span class="p">-&gt;</span> 
    <span class="n">BoolList</span> <span class="n">n</span> <span class="p">-&gt;</span> <span class="n">BoolList</span> <span class="n">m</span> <span class="p">-&gt;</span> <span class="n">BoolList</span> <span class="p">(</span><span class="n">plus</span> <span class="n">n</span> <span class="n">m</span><span class="p">)</span>
<span class="n">append</span> <span class="n">nil</span> <span class="n">l</span> <span class="p">=</span> <span class="n">l</span>
<span class="n">append</span> <span class="p">(</span><span class="n">cons</span> <span class="n">h</span> <span class="n">t</span><span class="p">)</span> <span class="n">l</span> <span class="p">=</span> <span class="n">cons</span> <span class="n">h</span> <span class="p">(</span><span class="n">append</span> <span class="n">t</span> <span class="n">l</span><span class="p">)</span>
</pre></div>


<p>Surprisingly, the program didn't change at all! However, the type checker in Agda will do a lot more work for you than it did in SML, as our type declaration is much, much richer in our Agda code.</p>
<p>Type checker's tasks:</p>
<div class="codehilite"><pre><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">l</span> <span class="p">:</span> <span class="n">BoolList</span> <span class="n">m</span> <span class="n">|-</span> <span class="n">l</span> <span class="p">:</span> <span class="n">BoolList</span> <span class="p">(</span><span class="n">plus</span> <span class="n">n</span> <span class="n">m</span><span class="p">)</span>
</pre></div>


<p>We need to prove that <code>BoolList m = BoolList (plus zero m)</code>. Show that <code>plus zero m =&gt; m</code>.</p>
<p>To check that two types are equal means we need to show that the index arguments are equal. This is based on evaluation!<br />
<span>$$    \frac{<code>BoolList m = BoolList m'</code>}{ m \Rightarrow m^{\prime}}$$</span></p>
<p>Agda works with total functions only -- i.e. those that are defined to work with all possible inputs. This way, the functions are provably terminating.</p>
<h2 class="header"><i>28</i>02 April<a class="headerlink" href="#02-april" name="02-april">&para;</a></h2>
<h3 class="header"><i>28.1</i>Dependent Types continued<a class="headerlink" href="#dependent-types-continued" name="dependent-types-continued">&para;</a></h3>
<div class="codehilite"><pre><span class="n">cons</span><span class="p">:</span> <span class="p">{</span><span class="n">n</span> <span class="p">:</span> <span class="n">Nat</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="n">Bool</span> <span class="p">-&gt;</span> <span class="n">BoolList</span> <span class="n">n</span> <span class="p">-&gt;</span> <span class="n">BoolList</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span>
</pre></div>


<p>For our append method (from Friday), consider the base case to be case 1 and the induction case to be step 2. To check case 1, can we show that <code>BoolList m = BoolList (plus zero m)</code>? <code>BoolList m</code> is the inferred type for <code>l</code> and the RHS is the expected type. Because <code>plus zero m =&gt; m</code>, we know that the two types are equal. </p>
<p>For case 2, we know <code>cons h t : BoolList (succ n')</code>, and therefore <code>t : BoolList n'</code>. <code>append t l : BoolList (plus n' m)</code>, so <code>cons h (append t l) : BoolList (succ (plus n' m))</code>.</p>
<p>Expected type: <code>BoolList (plus (succ n') m)</code>, because <code>plus (succ n') m =&gt; suc (plus n' m)</code>, so we know that the two types are equal.</p>
<p>Vectors: polymorphic lists</p>
<div class="codehilite"><pre><span class="n">data</span> <span class="n">Vec</span> <span class="p">(</span><span class="n">A</span> <span class="p">:</span> <span class="n">Set</span><span class="p">)</span> <span class="p">:</span> <span class="n">Nat</span> <span class="p">-&gt;</span> <span class="n">Set</span> <span class="kr">where</span>
     <span class="p">[]</span> <span class="p">:</span> <span class="n">Vec</span> <span class="n">A</span> <span class="n">zero</span>
     <span class="p">_</span><span class="n">::</span><span class="p">_</span> <span class="p">:</span> <span class="p">{</span><span class="n">n</span> <span class="p">:</span> <span class="n">Nat</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="n">A</span> <span class="p">-&gt;</span> <span class="n">Vec</span> <span class="n">A</span> <span class="n">n</span> <span class="p">-&gt;</span> <span class="n">Vec</span> <span class="n">A</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span>
 <span class="n">--</span> <span class="n">by</span> <span class="n">using</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">),</span> <span class="n">we&#39;re</span> <span class="n">prevented</span> <span class="n">from</span> <span class="n">ever</span> <span class="n">getting</span> <span class="n">a</span> <span class="n">list</span> <span class="kr">of</span> <span class="n">length</span> <span class="n">zero</span>
<span class="n">vhead</span> <span class="p">:</span> <span class="p">{</span><span class="n">A</span> <span class="p">:</span> <span class="n">Set</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="p">{</span><span class="n">n</span> <span class="p">:</span> <span class="n">Nat</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="n">Vec</span> <span class="n">A</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">A</span>
<span class="n">vhead</span> <span class="n">h::t</span> <span class="p">=</span> <span class="n">h</span>
</pre></div>


<p>Note that there is no case necessary for the empty list, so this <code>vhead</code> function is total.</p>
<div class="codehilite"><pre><span class="n">vtail</span> <span class="p">:</span> <span class="p">{</span><span class="n">A</span> <span class="p">:</span> <span class="n">Set</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="p">{</span><span class="n">n</span> <span class="p">:</span> <span class="n">Nat</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="n">Vec</span> <span class="n">A</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Vec</span> <span class="n">A</span> <span class="n">n</span>
<span class="n">vtail</span> <span class="n">h::t</span> <span class="p">=</span> <span class="n">t</span>
 <span class="n">vmap</span> <span class="p">:</span> <span class="p">{</span><span class="n">A</span> <span class="p">:</span> <span class="n">Set</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="p">{</span><span class="n">B</span> <span class="p">:</span> <span class="n">set</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="p">{</span><span class="n">n</span> <span class="p">:</span> <span class="n">Nat</span><span class="p">}</span> <span class="p">-&gt;</span>
    <span class="p">(</span><span class="n">A</span> <span class="p">-&gt;</span> <span class="n">B</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Vec</span> <span class="n">A</span> <span class="n">n</span> <span class="p">-&gt;</span> <span class="n">Vec</span> <span class="n">B</span> <span class="n">n</span>
<span class="n">vmap</span> <span class="n">f</span> <span class="p">[]</span> <span class="p">=</span> <span class="p">[]</span>
<span class="n">vmap</span> <span class="n">f</span> <span class="p">(</span><span class="n">h</span> <span class="n">::</span> <span class="n">t</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="n">f</span> <span class="n">h</span><span class="p">)</span><span class="n">::</span><span class="p">(</span><span class="n">vmap</span> <span class="n">f</span> <span class="n">t</span><span class="p">)</span>
 <span class="n">vzip</span> <span class="p">:</span> <span class="p">{</span><span class="n">A</span> <span class="p">:</span> <span class="n">Set</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="p">{</span><span class="n">B</span> <span class="p">:</span> <span class="n">Set</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="p">{</span><span class="n">n</span> <span class="p">:</span> <span class="n">Nat</span><span class="p">}</span> <span class="p">-&gt;</span>
    <span class="n">Vec</span> <span class="n">A</span> <span class="n">n</span> <span class="p">-&gt;</span> <span class="n">Vec</span> <span class="n">B</span> <span class="n">n</span> <span class="p">-&gt;</span> <span class="n">Vec</span> <span class="p">(</span><span class="n">A</span> <span class="n">*</span> <span class="n">B</span><span class="p">)</span> <span class="n">n</span>
<span class="n">vzip</span> <span class="p">[]</span> <span class="p">[]</span> <span class="p">=</span> <span class="p">[]</span>
<span class="n">vzip</span> <span class="p">(</span><span class="n">x::xs</span><span class="p">)</span> <span class="p">(</span><span class="n">y::xs</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="n">::</span><span class="p">(</span><span class="n">vzip</span> <span class="n">xs</span> <span class="n">ys</span><span class="p">)</span>
</pre></div>


<p>We'd also like to have a safe look-up function of the <span>$k$</span>th element in a vector:</p>
<div class="codehilite"><pre><span class="n">data</span> <span class="p">_</span> <span class="n">&lt;=</span> <span class="p">_</span> <span class="p">:</span> <span class="n">Nat</span> <span class="p">-&gt;</span> <span class="n">Nat</span> <span class="p">-&gt;</span> <span class="n">Set</span> <span class="kr">where</span>
     <span class="n">leq_zero</span> <span class="p">:</span> <span class="p">{</span><span class="n">n</span> <span class="p">:</span> <span class="n">Nat</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="n">zero</span> <span class="n">&lt;=</span> <span class="n">n</span>
     <span class="n">leq_succ</span> <span class="p">:</span> <span class="p">{</span><span class="n">n</span> <span class="n">m</span> <span class="p">:</span> <span class="n">Nat</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="n">n</span> <span class="n">&lt;=</span> <span class="n">m</span> <span class="p">-&gt;</span> <span class="n">succ</span> <span class="n">n</span> <span class="n">&lt;=</span> <span class="n">succ</span> <span class="n">m</span>
 <span class="n">kth</span> <span class="p">:</span> <span class="p">{</span><span class="n">A</span> <span class="p">:</span> <span class="n">Set</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="p">{</span><span class="n">n</span> <span class="p">:</span> <span class="n">Nat</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="p">{</span><span class="n">k</span> <span class="p">:</span> <span class="n">Nat</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="n">k</span> <span class="n">&lt;=</span> <span class="n">n</span> <span class="p">-&gt;</span> <span class="n">Vec</span> <span class="n">A</span> <span class="p">(</span><span class="n">succ</span> <span class="n">n</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">a</span>
<span class="n">kth</span> <span class="n">zero</span> <span class="n">leq_zero</span> <span class="p">(</span><span class="n">x::xs</span><span class="p">)</span> <span class="p">=</span> <span class="n">x</span>
<span class="n">kth</span> <span class="p">(</span><span class="n">succ</span> <span class="n">k</span><span class="p">)</span> <span class="p">(</span><span class="n">leq_succ</span> <span class="n">p</span><span class="p">)</span> <span class="p">(</span><span class="n">x::xs</span><span class="p">)</span> <span class="p">=</span> 
    <span class="n">kth</span> <span class="n">k</span> <span class="n">p</span> <span class="n">xs</span>
</pre></div>


<h2 class="header"><i>29</i>04 April<a class="headerlink" href="#04-april" name="04-april">&para;</a></h2>
<h3 class="header"><i>29.1</i>Type-Preserving Evaluator with Agda<a class="headerlink" href="#type-preserving-evaluator-with-agda" name="type-preserving-evaluator-with-agda">&para;</a></h3>
<p>The type-preserving evaluator also guarantees that only values are returned.</p>
<div class="codehilite"><pre><span class="n">Expressions</span> <span class="n">e</span> <span class="n">:=</span> <span class="n">true</span> <span class="n">|</span> <span class="n">false</span> <span class="n">|</span> <span class="n">zero</span> <span class="n">|</span> <span class="n">suc</span> <span class="n">e</span> <span class="n">|</span> <span class="n">pred</span> <span class="n">e</span>
                <span class="n">|</span> <span class="n">isZero</span> <span class="n">e</span> <span class="n">|</span> <span class="n">switch</span> <span class="n">e</span> <span class="n">e1</span> <span class="n">e2</span>
<span class="n">Values</span> <span class="n">v</span> <span class="n">:=</span> <span class="n">true</span> <span class="n">|</span> <span class="n">false</span> <span class="n">|</span> <span class="n">zero</span> <span class="n">|</span> <span class="n">suc</span> <span class="n">v</span>
<span class="n">Types</span> <span class="n">T</span> <span class="n">:=</span> <span class="n">Bool</span> <span class="n">|</span> <span class="n">Nat</span>
</pre></div>


<p>Well-typed expressions:</p>
<p><span>$$\frac{zero:Nat}{}$$</span><br />
<span>$$\frac{suc e : Nat}{e : Nat}$$</span><br />
<span>$$\frac{true : Bool}{}$$</span><br />
<span>$$\frac{false : Bool}{}$$</span><br />
<span>$$\frac{pred e : Nat}{e : Nat}$$</span><br />
<span>$$\frac{isZero e : Bool}{e : Nat}$$</span><br />
<span>$$\frac{switch e e1 e2 : T}{e : Bool&amp; e1 :T&amp;e1:T}$$</span></p>
<div class="codehilite"><pre><span class="n">data</span> <span class="n">tm</span> <span class="p">:</span> <span class="n">Tp</span> <span class="p">-&gt;</span> <span class="n">Set</span> <span class="kr">where</span>
    <span class="n">true</span> <span class="p">:</span> <span class="n">Tm</span> <span class="n">Bool</span>
    <span class="n">false</span> <span class="p">:</span> <span class="n">Tm</span> <span class="n">Bool</span>
    <span class="n">zero</span> <span class="p">:</span> <span class="n">Tm</span> <span class="n">Nat</span>
    <span class="n">suc</span> <span class="p">:</span> <span class="n">Tm</span> <span class="n">Nat</span> <span class="p">-&gt;</span> <span class="n">Tm</span> <span class="n">Nat</span>
    <span class="n">pred</span> <span class="p">:</span> <span class="n">Tm</span> <span class="n">Nat</span> <span class="p">-&gt;</span> <span class="n">Tm</span> <span class="n">Nat</span>
    <span class="n">isZero</span> <span class="p">:</span> <span class="n">Tm</span> <span class="n">Nat</span> <span class="p">-&gt;</span> <span class="n">Tm</span> <span class="n">Bool</span>
    <span class="n">switch</span> <span class="p">:</span> <span class="p">{</span><span class="n">t</span> <span class="p">:</span> <span class="n">Tp</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="n">Tm</span> <span class="n">Bool</span> <span class="p">-&gt;</span> <span class="n">Tm</span> <span class="n">t</span> <span class="p">-&gt;</span> <span class="n">Tm</span> <span class="n">t</span> <span class="p">-&gt;</span> <span class="n">Tm</span> <span class="n">t</span>
<span class="n">data</span> <span class="n">Tp</span> <span class="p">:</span> <span class="n">Set</span> <span class="kr">where</span>
    <span class="n">Bool</span> <span class="p">:</span> <span class="n">Tp</span>
    <span class="n">Nat</span> <span class="p">:</span> <span class="n">Tp</span>
</pre></div>


<p>With these data definitions, <code>suc true</code> and <code>switch zero true false</code> will be ill-typed in Agda!</p>
<p>Defining values:</p>
<div class="codehilite"><pre><span class="n">data</span> <span class="n">Value</span> <span class="p">:</span> <span class="n">Tp</span> <span class="p">-&gt;</span> <span class="n">Set</span> <span class="kr">where</span>
    <span class="n">vtrue</span> <span class="p">:</span> <span class="n">Value</span> <span class="n">Bool</span>
    <span class="n">vfalse</span> <span class="p">:</span> <span class="n">Value</span> <span class="n">Bool</span>
    <span class="n">vzero</span> <span class="p">:</span> <span class="n">Value</span> <span class="n">Nat</span>
    <span class="n">vsuc</span> <span class="p">:</span> <span class="n">Value</span> <span class="n">Nat</span> <span class="p">-&gt;</span> <span class="n">Value</span> <span class="n">Nat</span>
</pre></div>


<p>Types are preserved during evaluation -- <em>type safety</em>.</p>
<div class="codehilite"><pre><span class="n">eval</span> <span class="p">:</span> <span class="p">{</span><span class="n">t</span> <span class="p">:</span> <span class="n">Tp</span><span class="p">}</span> <span class="p">-&gt;</span> <span class="n">Tm</span> <span class="n">t</span> <span class="p">-&gt;</span> <span class="n">Value</span> <span class="n">t</span>
    <span class="n">eval</span> <span class="n">true</span> <span class="p">=</span> <span class="n">vtrue</span>
    <span class="n">eval</span> <span class="n">false</span> <span class="p">=</span> <span class="n">vfalse</span>
    <span class="n">eval</span> <span class="n">zero</span> <span class="p">=</span> <span class="n">vzero</span>
    <span class="n">eval</span> <span class="p">(</span><span class="n">suc</span> <span class="n">e</span><span class="p">)</span> <span class="p">=</span> <span class="n">vsuc</span> <span class="p">(</span><span class="n">eval</span> <span class="n">e</span><span class="p">)</span>
    <span class="n">eval</span> <span class="p">(</span><span class="n">pred</span> <span class="n">e</span><span class="p">)</span> <span class="kr">with</span> <span class="n">eval</span> <span class="n">e</span>
    <span class="p">...</span> <span class="n">|</span> <span class="n">vzero</span> <span class="p">=</span> <span class="n">vzero</span>
    <span class="p">...</span> <span class="n">|</span> <span class="n">vsuc</span> <span class="p">_</span> <span class="p">=</span> <span class="n">v</span>
</pre></div>


<p><em>Note:</em> these are the only possible two cases, since <code>eval e</code> produces a value of type <code>Tm Nat</code> because <code>e</code> has type <code>Nat</code>.</p>
<div class="codehilite"><pre><span class="n">--</span> <span class="p">...</span>
<span class="n">eval</span> <span class="p">(</span><span class="n">iszero</span> <span class="n">e</span><span class="p">)</span> <span class="kr">with</span> <span class="n">eval</span> <span class="n">e</span>
<span class="p">...</span><span class="n">|</span> <span class="n">vzero</span> <span class="p">=</span> <span class="n">vtrue</span>
<span class="p">...</span><span class="n">|</span> <span class="n">vsuc</span> <span class="n">v</span> <span class="p">=</span> <span class="n">vfalse</span>
<span class="n">eval</span> <span class="p">(</span><span class="n">switch</span> <span class="n">e</span> <span class="n">e1</span> <span class="n">e2</span><span class="p">)</span> <span class="kr">with</span> <span class="n">eval</span> <span class="n">e</span>
<span class="p">...</span><span class="n">|</span> <span class="n">vtrue</span> <span class="p">=</span> <span class="n">eval</span> <span class="n">e1</span>
<span class="p">...</span><span class="n">|</span> <span class="n">vfalse</span> <span class="p">=</span> <span class="n">eval</span> <span class="n">e2</span>
</pre></div>


<p>Agda enforces whitespace, similar to Python. Comments are prefaced by <code>--</code>. Within the Emacs environment, Agda has incremental type checking -- see documentation for details. In-class examples also include the pair/tuple term, the <code>cross</code> type, and the <code>fst</code> and <code>scd</code> functions with all the relevant evaluation functions.</p>
<h2 class="header"><i>30</i>11 April<a class="headerlink" href="#11-april" name="11-april">&para;</a></h2>
<h3 class="header"><i>30.1</i>Object-Oriented vs Functional<a class="headerlink" href="#object-oriented-vs-functional" name="object-oriented-vs-functional">&para;</a></h3>
<h4 class="header"><i>30.1.1</i>Classes and types<a class="headerlink" href="#classes-and-types" name="classes-and-types">&para;</a></h4>
<p>In a language like Java:</p>
<div class="codehilite"><pre><span class="n">Class</span> <span class="n">A</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
           <span class="o">^</span>
           <span class="o">|</span>
          <span class="n">methods</span><span class="o">,</span> <span class="n">fields</span>

<span class="n">Class</span> <span class="n">B</span> <span class="kd">extends</span> <span class="n">A</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div>


<p>To say that <code>B extends A</code>, two things happen at the same time: inheritance (single inheritance only in Java) and subtyping.</p>
<p>Class B can add more methods and fields and/or overwrite methods. The same method exists in A and in B and it has the same types.</p>
<p>Example:</p>
<div class="codehilite"><pre><span class="kd">class</span> <span class="nc">myInt</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
    <span class="cm">/* ... */</span>
    <span class="kd">public</span> <span class="n">myInt</span> <span class="nf">add</span> <span class="o">(</span><span class="n">myInt</span> <span class="n">N</span><span class="o">){</span>
        <span class="cm">/* ... */</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show</span> <span class="o">()</span> <span class="o">{</span>
        <span class="cm">/* ... */</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">gaussInt</span> <span class="kd">extends</span> <span class="n">myInt</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">m</span><span class="o">;</span> <span class="c1">// imaginary part</span>
    <span class="cm">/* ... */</span>
    <span class="c1">// overloading example</span>
    <span class="kd">public</span> <span class="n">gaussInt</span> <span class="nf">add</span> <span class="o">(</span><span class="n">gaussInt</span> <span class="n">z</span><span class="o">){</span>
        <span class="cm">/* ... */</span>
    <span class="o">}</span>
    <span class="c1">// overwriting example</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show</span> <span class="o">()</span> <span class="o">{</span>
        <span class="cm">/* ... */</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>The <code>B extends A</code> construct is an example of nominal subtyping.</p>
<p>There is no multiple inheritance in Java, but there is multiple subtyping.</p>
<p>Overloading -- same method name, different input types. </p>
<p>Typechecking needs to OK all method calls before running. All typechecking happens on the declared type. Subtyping is an integral part. Method lookup is based on the actual type of an object. Overloading is resolved by typechecking during runtime. </p>
<div class="codehilite"><pre><span class="n">myInt</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">myInt</span> <span class="o">(</span><span class="mi">3</span><span class="o">);</span>
<span class="n">gaussInt</span> <span class="n">z</span> <span class="o">=</span> <span class="k">new</span> <span class="n">gaussInt</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">);</span>
<span class="n">myInt</span> <span class="n">b</span> <span class="o">=</span> <span class="n">z</span><span class="o">;</span> <span class="c1">// OK because gaussInt &lt;= myInt</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;The value of z is &quot;</span> <span class="o">+</span> <span class="n">z</span><span class="o">.</span><span class="na">show</span><span class="o">());</span> <span class="c1">// OK</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;The value of b is &quot;</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="na">show</span><span class="o">());</span> <span class="c1">// uses show from gaussInt</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="na">realPart</span> <span class="o">();</span> <span class="c1">// fine, so long as gaussInt has this method</span>
<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="na">realPart</span> <span class="o">();</span> 
    <span class="c1">// typechecking will say no, although, during run time, we know that b is actually</span>
    <span class="c1">// a gaussInt</span>
<span class="n">myInt</span> <span class="n">d</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">);</span> <span class="c1">// chooses during runtime the method add from myInt</span>
<span class="n">gaussInt</span> <span class="n">w</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
</pre></div>


<p>Functionality = functions via pattern matching. All the functionality is in one place.</p>
<p>In SML:</p>
<div class="codehilite"><pre><span class="kr">datatype</span> <span class="kt">persons</span> <span class="p">=</span>
    <span class="nc">|</span> <span class="n">Doctor</span> <span class="kr">of</span> <span class="n">string</span>
    <span class="p">|</span> <span class="nc">Nurse</span> <span class="kr">of</span> <span class="n">string</span>
    <span class="p">|</span> <span class="nc">Patient</span> <span class="kr">of</span> <span class="n">string</span>

<span class="kr">fun</span> <span class="nf">display</span> <span class="p">(</span><span class="n">Nurse</span> <span class="n">s</span><span class="p">)</span> <span class="p">=</span> <span class="p">...</span>
  <span class="p">|</span> <span class="nf">display</span> <span class="p">(</span><span class="n">Doctor</span> <span class="n">d</span><span class="p">)</span> <span class="p">=</span> <span class="p">...</span>
  <span class="p">|</span> <span class="nf">display</span> <span class="p">(</span><span class="n">Patient</span> <span class="n">p</span><span class="p">)</span> <span class="p">=</span> <span class="p">...</span>
</pre></div>


<p>In Java:  </p>
<div class="codehilite"><pre><span class="n">Class</span> <span class="n">Doctors</span> <span class="kd">extends</span> <span class="n">personnel</span> <span class="o">{</span>
    <span class="cm">/* ... */</span>
<span class="o">}</span>
<span class="n">Class</span> <span class="n">Nurses</span> <span class="kd">extends</span> <span class="n">personnel</span> <span class="o">{</span>
    <span class="cm">/* ... */</span>
<span class="o">}</span>
</pre></div>


<p>In Java, functionality scattered. This isn't necessarily bad, depending on what you want to do, but there are different consequences.</p>
<p>In functional languages, it's easy to add new functionality to functions, but harder to add new persons. In OO languages, it's hard to add new functionality to methods, but it's much easier to add a new class of people. There are many trade-offs you have to take into consideration.</p>
<h2 class="header"><i>31</i>13 &amp; 16 April<a class="headerlink" href="#13-16-april" name="13-16-april">&para;</a></h2>
<p>The lecture notes for these last two classes were compiled and posted by <a href="/users/ejanco">@ejanco</a>.</p>
<h3 class="header"><i>31.1</i>Induction Proof Example<a class="headerlink" href="#induction-proof-example" name="induction-proof-example">&para;</a></h3>
<div class="codehilite"><pre><span class="kr">fun</span> <span class="nf">size</span> <span class="p">(</span><span class="n">Leaf</span><span class="p">)</span> <span class="p">=</span> <span class="mi">0</span>
  <span class="p">|</span> <span class="nf">size</span> <span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">))</span> <span class="p">=</span>
      <span class="n">root</span> <span class="n">+</span> <span class="n">size</span> <span class="n">L</span> <span class="n">+</span> <span class="n">size</span> <span class="n">R</span>

<span class="kr">fun</span> <span class="nf">size_tl</span> <span class="p">(</span><span class="n">Leaf</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="p">=</span> <span class="n">acc</span>
  <span class="p">|</span> <span class="nf">size_tl</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">),</span> <span class="n">acc</span><span class="p">)</span> <span class="p">=</span>
      <span class="n">size_tl</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">size_tl</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">root</span> <span class="n">+</span> <span class="n">acc</span><span class="p">))</span>
</pre></div>


<p><strong>To prove: size T = size_tl (T, 0)</strong></p>
<div class="ui divider"></div>
<blockquote>
<p>case T = Node(root, L, R)<br />
<strong>IH1</strong> size L = size_tl(L,0)<br />
<strong>IH2</strong> size R = size_tl(R,0)</p>
</blockquote>
<p><em>Does not work :(</em></p>
<p>Instead,<br />
Use lemma, choosing acc=0</p>
<p><strong>Lemma: size T + acc = size_tl(T, acc)</strong></p>
<p>By induction on T,</p>
<blockquote>
<p><strong>Base Case</strong>: T = Leaf<br />
size Leaf + acc =&gt; 0 + acc =&gt; acc<br />
size_tl(Leaf, acc) =&gt; acc</p>
</blockquote>
<p>Therefore, these two sides are equal.</p>
<blockquote>
<p><strong>Step Case</strong>: T = Node(root, L, R)<br />
<strong>IH1</strong>: For all accumulators:<br />
size L + acc_L = size_tl(L, acc_L)<br />
<strong>IH2</strong>: For all accumulators:<br />
size R + acc_R = size_tl(R, acc_R)</p>
<p>size_tl(Node(root, L, R), acc)<br />
=&gt; size_tl(L, size_tl(R, root+acc))</p>
<p>By IH2, using root+acc = acc_R<br />
=&gt; size_tl(L, size R + (root + acc))<br />
By IH1, using acc = size R + (root + acc)<br />
=&gt; size L + (size R + (root+acc))</p>
<p>By assoc + comm<br />
= root + size L + size R + acc</p>
<p>size(Node(root,L,R)) + acc<br />
=&gt; root + size L + size R + acc</p>
</blockquote>
<p>They're the same!, <strong>QED</strong></p>
<h3 class="header"><i>31.2</i>Backtracking<a class="headerlink" href="#backtracking" name="backtracking">&para;</a></h3>
<h4 class="header"><i>31.2.1</i>With Exceptions<a class="headerlink" href="#with-exceptions" name="with-exceptions">&para;</a></h4>
<div class="codehilite"><pre><span class="kr">datatype</span> <span class="nd">&#39;a</span> <span class="kt">tree</span> <span class="p">=</span> <span class="nc">Empty</span> <span class="p">|</span> <span class="nc">Node</span> <span class="kr">of</span> <span class="nd">&#39;a</span> <span class="n">tree</span> <span class="n">*</span> <span class="nd">&#39;a</span> <span class="n">*</span> <span class="nd">&#39;a</span> <span class="n">tree</span>
<span class="kr">exception</span> <span class="nc">FoundSoFar</span> <span class="kr">of</span> <span class="n">int</span> <span class="n">list</span>
<span class="cm">(* Exception are not polymorphic - We NEED to use int *)</span>
</pre></div>


<p><strong>Task</strong>: Find all elements which satisfy a given predicate p</p>
<div class="codehilite"><pre><span class="kr">fun</span> <span class="nf">findAll&#39;</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Empty</span><span class="p">)</span> <span class="p">=</span>
      <span class="kr">raise</span> <span class="n">FoundSoFar</span> <span class="p">[]</span>
  <span class="p">|</span> <span class="nf">findAll&#39;</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Node</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">R</span><span class="p">))</span> <span class="p">=</span>
      <span class="n">findAll&#39;</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
      <span class="kr">handle</span> <span class="n">FoundSoFar</span> <span class="n">ll</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">findAll&#39;</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">R</span><span class="p">)</span>
        <span class="kr">handle</span> <span class="n">FoundSoFar</span> <span class="n">lr</span> <span class="p">=&gt;</span> <span class="kr">if</span> <span class="p">(</span><span class="n">p</span> <span class="n">d</span><span class="p">)</span> <span class="kr">then</span> <span class="kr">raise</span> <span class="n">FoundSoFar</span> <span class="p">(</span><span class="n">ll@</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="n">@lr</span><span class="p">)</span>
                                <span class="kr">else</span> <span class="kr">raise</span> <span class="n">FoundSoFar</span> <span class="p">(</span><span class="n">ll@lr</span><span class="p">))</span>

<span class="kr">fun</span> <span class="nf">findAll</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="p">=</span>
      <span class="p">(</span><span class="n">findAll&#39;</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
       <span class="kr">handle</span> <span class="n">FoundSoFar</span> <span class="n">l</span> <span class="p">=&gt;</span> <span class="n">l</span><span class="p">)</span>
</pre></div>


<h4 class="header"><i>31.2.2</i>With continuations<a class="headerlink" href="#with-continuations" name="with-continuations">&para;</a></h4>
<div class="codehilite"><pre><span class="kr">fun</span> <span class="nf">findAllCont&#39;</span> <span class="n">p</span> <span class="n">Empty</span> <span class="n">cont</span> <span class="p">=</span> <span class="n">cont</span> <span class="p">[]</span>
  <span class="p">|</span> <span class="nf">findAllCont&#39;</span> <span class="n">p</span> <span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">R</span><span class="p">))</span> <span class="n">cont</span> <span class="p">=</span>
      <span class="n">findAllCont&#39;</span> <span class="n">p</span> <span class="n">L</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">ll</span> <span class="p">=&gt;</span> <span class="n">findAllCont&#39;</span> <span class="n">p</span> <span class="n">R</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">lr</span> <span class="p">=&gt;</span> <span class="kr">if</span> <span class="n">p</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="kr">then</span> <span class="n">cont</span> <span class="p">(</span><span class="n">ll@</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="n">@lr</span><span class="p">)</span>
                                                       <span class="kr">else</span> <span class="n">cont</span> <span class="p">(</span><span class="n">ll@lr</span><span class="p">)))</span>

<span class="cm">(* Notice the similarities with the exceptions *)</span>

<span class="kr">fun</span> <span class="nf">findAllCont</span> <span class="n">p</span> <span class="n">T</span> <span class="p">=</span> <span class="n">findAllCont&#39;</span> <span class="n">p</span> <span class="n">T</span> <span class="p">(</span><span class="kr">fn</span> <span class="n">l</span> <span class="p">=&gt;</span> <span class="n">l</span><span class="p">)</span>
</pre></div>


<h3 class="header"><i>31.3</i>Environment Diagram<a class="headerlink" href="#environment-diagram" name="environment-diagram">&para;</a></h3>
<div class="codehilite"><pre><span class="kr">let</span> <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">5</span>
    <span class="kr">val</span> <span class="nv">r</span> <span class="p">=</span> <span class="n">ref</span><span class="p">(</span><span class="mi">10</span><span class="n">+x</span><span class="p">)</span>
    <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="kr">fun</span> <span class="nf">foo</span> <span class="n">x</span> <span class="p">=</span> <span class="kr">let</span> <span class="kr">val</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">10</span> <span class="kr">in</span> <span class="n">!r</span> <span class="n">+</span> <span class="n">x</span> <span class="kr">end</span>
    <span class="kr">val</span> <span class="p">_</span> <span class="p">=</span> <span class="p">(</span><span class="n">r</span> <span class="n">:=</span> <span class="n">x+</span><span class="mi">1</span><span class="p">)</span>
<span class="kr">in</span>
    <span class="n">foo</span><span class="p">(</span><span class="n">x</span> <span class="n">+</span> <span class="n">!r</span><span class="p">)</span>
<span class="kr">end</span>
</pre></div>


<div class="ui divider"></div>
<p><img alt="Environment Diagram" src="http://cs.mcgill.ca/~ejanco/envi.png" /></p>
	
    </div>
</div>

        </div>
    </div>
    <div id="footer" class="ui container">
        <div class="ui stackable grid">
            <div class="twelve wide column">
                <p>
                    Built by <a href="https://twitter.com/dellsystem">
                    @dellsystem</a>. Content is student-generated. <a
                    href="https://github.com/dellsystem/wikinotes">See the old codebase on GitHub</a>
                </p>
            </div>
            <div class="four wide right aligned column">
                <p><a href="#header">Back to top</a></p>
            </div>
        </div>
    </div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-28456804-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
</html>
